---
title:  "[Python] Numpy-2"
header:
  teaser: "/assets/image/1*cyXCE-JcBelTyrK-58w6_Q.png"
categories: 
  - Python
tags:
  - Numpy

---

## Numpy -2

오늘은 numpy 에 대하여 조금 더 알아보도록 하겠습니다.

### Reshape vs Resize

numpy 내장 함수인 `reshape` 와 `resize`에 대하여 알아보겠습니다. `reshape` 와 `resize`는 행렬의 array를 shape을 변경하는 점에서 동일하나 차이점이 한가지가 있습니다. 

`reshape` 이전의 행렬의 인자의 개수와 변경될 인자의 개수가 동일해야만 사용할 수 있습니다. 

하지만 `resize` 경우에는 상관없이 사용가능합니다. 이전에 비해 인자가 부족할 경우 나머지 요소를 0으로 채우고, 남는경우에는 필요한 요소를 제외하고는 전부다 버려 행렬을 완성합니다.

하기 예제를 보며 차이점을 알아보도록 하겠습니다.

``` python
import numpy as np

#정수형태의 난수를 이용해서 (3,4) shape을 가지는 ndarray를 생성할 꺼에요!
np.random.seed(10)
arr = np.random.randint(0,10,(3,4))
print(arr)

result = arr.resize(2,6) # 원본을 변경
print(result) # None
print(arr)

arr.resize(3,5)
 # reshape은 안됨 error 하지만 resize는 나머지 요소를 0으로 맞춤
print(arr)

arr.resize(2,2)
 # 요소수가 줄면 나머지데이터를 버립니다.
print(arr)
```



### Indexing & Slicing

`Indexing`과  `Slicing` 모두 List 혹은 문자열에서 많이 사용하였습니다. 하지만 `Numpy`에서도 비슷하게 사용할 수 있습니다. 

자세한 내용은 하기 코드를 보면서 익혀보도록 하겠습니다. 

#### Indexing

``` python
import numpy as np
arr = np.arange(10,20,1)
print(arr)

ndarray의 각요소를 축력하려면 어떻게 해야하나요?
for tmp in arr:
    print(tmp)

for (idx, tmp) in enumerate(arr):
    print('인덱스 : {}, 데이터 : {}'.format(idx, tmp))
'''
인덱스 : 0, 데이터 : 10
인덱스 : 1, 데이터 : 11
인덱스 : 2, 데이터 : 12
인덱스 : 3, 데이터 : 13
인덱스 : 4, 데이터 : 14
인덱스 : 5, 데이터 : 15
인덱스 : 6, 데이터 : 16
인덱스 : 7, 데이터 : 17
인덱스 : 8, 데이터 : 18
인덱스 : 9, 데이터 : 19
'''
```


#### Slicing

```python
arr = np.arange(10,20,1)
print(arr[3]) # 13
print(arr[1:4]) # slicing은 원본의 형태를 그대로 가져옴
print(arr[:-1]) #[10 11 12 13 14 15 16 17 18]
print(arr[1:-1:2]) #[11 13 15 17] ,없이 표현
arr = np.arange(1,17,1).reshape(4,4).copy()
print(arr)
'''
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]
 [13 14 15 16]]
'''
print(arr[1,2]) # 7
print(arr[1][2]) # 7

print(arr[2,:]) #[ 9 10 11 12]
print(arr[1:3,:])
'''
[[ 5  6  7  8]
 [ 9 10 11 12]]
'''
print(arr[1:3,:2])
'''
[[ 5  6]
 [ 9 10]]
'''
```



### Boolean indexing & Fancy indexing

Numpy에는 특수한 indexing 방식이 있습니다.  `Boolean indexing `과 `Fancy indexing` 입니다. 

먼저 `Boolean indexing` 부터 알아보도록 하겠습니다.

#### Boolean indexing

True, False로 구성된 Boolean mask를 이용하여 지정하는 방식입니다. boolean mask의 True에 해당하는 index 만을 조회하는 방식으로도 활용이 가능합니다.  즉 boolean indexing은 ndarray의 각 요소의 선택여부를 결정할 수 있습니다.

예제를 통하여 알아보도록 하겠습니다. 

``` python
import numpy as np
np.random.seed(1)
arr = np.random.randint(0,10,(5,))
print(arr) # [5 8 9 5 0]
print(arr % 2) # [1 0 1 1 0]
print(arr % 2 == 0) # [False  True False False  True] => boolean mask
print(arr[arr % 2 == 0]) # [8 0] => boolean indexing
```

#### Fancy indexing

ndarray에 index배열을 전달하여 배열요소를 참조하는 방식입니다.

예제를 통하여 알아보도록 하겠습니다. 

``` python
import numpy as np
arr = np.arange(0,12,1).reshape(3,4).copy()
print(arr)
print(arr[2,2]) # indexing : 10
print(arr[1:2, 2]) # slicing : [6]
print(arr[1:2, 1:2]) # slicing : [[5]] => 차원 주의 !!
print(arr[[0,2],2]) # [ 2 10]
print(arr[[0,2],2:3]) 
'''
[[ 2]
 [10]]
'''
# 그렇다면 우리 다음의 2차원 ndarray를 추출해 보아요!!
'''
[[1 3]
 [9 11]]
''' 
print(arr[[0,2],[1,3]]) #[ 1 11] 행과 열에 동시에 fancy indexing을 할수가 없어요 !

# 해결방법 1
print(arr[[0,2]][:,[1,3]])
'''
[[1 3]
 [9 11]]
'''

# 해결방법 2 - numpy 가 함수를 하나 제공해줘요!
print(arr[np.ix_([0,2],[1,3])])
'''
[[1 3]
 [9 11]]
'''
```



### ndarray의 사칙연산과 행렬곱 

행렬도 행렬간의 덧셈, 뺄쎔, 나눗셈, 곱셈, 그리고 행렬곱을 실시할 수 있습니다.

행렬곱은 numpy에세 제공하는 dot product를 사용하여 쉽게 구할 수 있습니다.

예제를 통하여 알아보도록 하겠습니다. 

```python
import numpy as np
arr1 = np.array([[1,2,3],[4,5,6]])
arr2 = np.array([[7,8,9],[10,11,12]])
# python에서 list 할때.. + 얀산자는 concatenation!!
# ndarray에서 연산자는 vector, matrix연산..
# ndarray의 사칙연산의 기본 전제는.. shape이 같아야 연산이 성립
print(arr1 + arr2)
'''
[[ 8 10 12]
 [14 16 18]]
'''
arr2 = 3 

print(arr1 + arr2) # 수행이 되요 !! => ndarray가 broadcatin 을 수행
# shape 이 맞지않는 경우 ndarray 가 broadcating을 수행
# arr2 = [[3 3 3] 
#         [3 3 3]]

arr2 = np.array([1,2,3])

print(arr1 + arr2)

'''
[[2 4 6]
 [5 7 9]]
'''

arr2 = np.array([1,2]) # shape을 맞출수가 없음 => 1,2,1,2 이런식으로 복제가 실행되기 떄문에 

print(arr1 + arr2) # error
arr1 = np.array([[1,2,3],[4,5,6]])
arr2 = np.array([[7,8,9],[10,11,12]])

## 행렬곱 연산!!

print(arr1 * arr2) # 단순 곱셈만 실행
'''
[[ 7 16 27]
 [40 55 72]]
'''

# 두 행렬간의 행렬곱은 np.dot(), np.matmul()로 수행이 가능해요!!
# np.dot(A, B)에서 A행렬의 열 vector와 B행렬의 행 Vector의 size가 같아야 해요!
# 만약 크기가 다르면 reshape() 이나 resize()나
# 이런것들을 이용해서 크기를 맞추고 연산을 수행해야 해요!!

arr1 = np.array([[1,2,3],[4,5,6]])
arr2 = np.array([[7,8],[9,10],[11,12]])
print(np.dot(arr1, arr2))

# 왜 이런 행렬곱 연산을 알아야 하나요??
# 만약에 행렬곱이 없으면 Matrix 연산은 같은 크기로만 연산을 수행해야 해요!!
# 하지만 행렬곱 연산을 이용하면
# 행렬곱 조건만 만족시키면 다양한 크기의 행렬을 우리가 연속적으로
# 이용해서 특정 작업을 수행할 수 있어요 !!
# 머신러닝, 이미지처리쪽에서 사용되요!!
# 예) 입력 : 32 X 32 matrix (이미지파일)
#    출력 : 32 X 10 matrix (다양한 처리가 적용된 이미지)
#    행렬곱 : (32 X 32) dot(32 X 128) dot (128 X 64) dot (64 X 10 ) = (32 X 10)
```



### Transpose

`Transpose (전체행렬)`에 대하여 알아보도록 하겠습니다. 전치행렬은 행과 열을 바꾼 행렬을 의미하며 윗첨자로 T를 사용합니다.

예제를 통하여 알아보도록 하겠습니다. 

``` python
import numpy as np
arr = np.array([[1,2,3],[4,5,6]]) # 2 X 3 ndarray
print(arr)
t_arr = arr.T
print(t_arr)
arr[0,0] = 100
print(arr)
print(t_arr)


arr = np.array([1,2,3,4]) # vector (1차원 ndarray)
t_array = arr.T.reshape(4,1)
print(t_array)
```

