var store = [{
        "title": "테크블로그에 오신것을 환영합니다.",
        "excerpt":"    한솔   1990.04.09   경력 사항       육군 중위 (2013.03 - 2015.06)      아트라스콥코 (2016.11 - 2020.06)      KSA (OREAN STANDARDS ASSOCIATION) 전문요원      기업출강 및 제휴강의 담당 (삼성전자, SK 하이닉스, 현대자동차, LG전자 등)      외국계 기업 B2B 마케팅 담당      공장 개선 컨설팅 및 스마트팩토리 컨설팅 담당      각종 고객 세미나, 전시회 및 테크 쇼 기획 및 실행 담당      마케팅 캠페인 기획 및 관리 담당      비디오, 리플렛, 카탈로그 등 마케팅 자료 기획 및 제작 담당      기업 및 산업용 공구 사업부 SNS채널 및 뉴스레터 플랫폼 기획 및 관리 담당      KC인증, Cleanroom certification, 안전인증 담당      기술 특허 담당    보유기술       2D, 3D 설계 / 3D Printing      Co-bot operation 및 로봇 제어      PLC      Python      HTML, CSS, JavaScript   ","categories": ["Welcome"],
        "tags": [],
        "url": "http://localhost:4000/welcome/welcome/",
        "teaser": "https://cdn.pixabay.com/photo/2015/05/09/23/46/welcome-sign-760358__480.jpg"
      },{
        "title": "[Python] Idexing, Slicing (str Data Type)",
        "excerpt":"Indexing &amp; Slicing  오늘은 파이썬의 문자열 의 Idexing 과 Slicing을 알아보겠습니다.   Indexing #문자열에 번호에 해당하는 문자를 추출하려면??   python은 배열이 존재 하지 않아요! 하지만 다른언어에서는 - index 사용가능합니다.   그렇다면 파이썬의 문자열에서 번호 혹은 순서에 맞는 문자를 추출하기 위해서는 어떻게 해야할까요 ?   하기 그림은 문자열에 해당되는 번호를 명시한 그림입니다.    \t   그렇다면 그림에 해당하는 번호를 파이썬 코드로 구현해볼까요?   my_var = 'HELLO' print(my_var[1])  #E   Slicing #문자열에 범위를 선정하여 추출하려면??   Slicing은 말 그대로 잘라내다입니다. Indexing과의 차이점은 번호가 아닌 범위로 문자열을 추출이 가능합니다.   하기 예제를 확인하면서 익혀보도록 하겠습니다.   my_var = 'HELLO' print(my_var[0:3]) #HEL print(my_var[0:]) #HELLO print(my_var[0:-1]) #HELL print(my_var[-2:]) #LO print(my_var[:]) # HELLO    오늘은 파이썬의 Indexing과 Slicing에 대하여 알아보았습니다.  ","categories": ["Python"],
        "tags": ["Text sequence","Data Type","문자열","데이터타입","str","Idexing","Slicing"],
        "url": "http://localhost:4000/python/Idexing-Slicing/",
        "teaser": "https://miro.medium.com/max/2646/1*GokwxHxq5I-Myy3_ummrtw.png"
      },{
        "title": "[Python] In Not in (str Data Type)",
        "excerpt":"In Not In 연산자  오늘은 파이썬의 문자열 의 in 과 not in 연산자에 대하여 키워드를 통하여 알아보도록 하겠습니다.   In, Not in 연산자 #문자나 문자열이 포함되어 있는지 확인하려면 ??   예제를 통하여 다시 한번 정확하게 알아보겠습니다.   myStr = \"This is a sample Test\" print(\"sample\" in myStr) # True / 대소문자 구별 print(\"sample\" not in myStr) #False / 대소문자 구별   즉 sample이라는 문자열이 myStr이라는 변수에 포함되어있는지 안되어 있는지 확인이 가능합니다.   오늘은 파이썬의 in과 not in에 대하여 알아보았습니다.  ","categories": ["Python"],
        "tags": ["Text sequence","Data Type","문자열","데이터타입","str","In","Not in"],
        "url": "http://localhost:4000/python/In-Not/",
        "teaser": "http://localhost:4000/assets/image/INNOTIN.png"
      },{
        "title": "[Python] Numeric Data Type",
        "excerpt":"Numeric Data Type (숫자형)  오늘은 파이썬의 숫자형 데이터 타입에 대하여 알아보겠습니다.   데이터 숫자는 크게 3가지로 나눌 수가 있습니다!      int(정수)   float(실수)   complex(복소수)   하기 예제를 보면서 파이썬의 특징을 알아보겠습니다.  a = 100 # 정수 b = 3.14159265358979 # 실수 c = 1+ 2j # 복소수 d = 0o34 # 8 진수 e = 0xAB # 16 진수  파이썬이 아닌 다른 프로그램언어를 배우신 분이라면 변수선언을 할때 var같은 선언을 하지않고 간편하게 변수를 선언을 할 수 있습니다.   Type # 데이터 타입에 대하여 알기를 원한다면??  print (type(a)) # class int print (type(b)) # class float print (type(c)) # class complex print (type(d)) # class int print (type(e)) # class int   Python의 연산의 특징에 대하여 알아보아요!  my_result = 3 / 4 # 0이 아니라 0.75  프로그래밍에서는 버림으로 표시 print(my_result) # 0.75   my_result = 10 % 3 #나머지 연산자 print(my_result) # 1  my_result = 10 // 3 #몫 연산자 print(my_result) # 3   오늘은 파이썬의 숫자형 데이터 타입에 대하여 알아보았습니다.  ","categories": ["Python"],
        "tags": ["Numeric","Data Type","숫자형","데이터타입"],
        "url": "http://localhost:4000/python/Numeric-Data-Type/",
        "teaser": "http://localhost:4000/assets/image/Numeric.png"
      },{
        "title": "[Python] Text operation (str Data Type)",
        "excerpt":"문자열의 연산 (문자열, str)  오늘은 파이썬의 문자열 연산에 대하여 알아보겠습니다.   일상생활에서 말을 할때 대부분 단일언어로 대화를 하지않습니다. 문자를 조합하거나 합성해서 문장을 만들어 대화를 합니다.   파이썬의 문자열도 마찬가지로 합치거나 원하는 문자열을 추가를 할 수가 있습니다. 자세한 내용은 하기 예제를 통하여 알아보겠습니다.   first = 'haha' second = 'hoho'  print(first + second) #hahahoho print(first + str(10)) # error 자동으로 숫자를 문자로 변경 X ( Java 에서는 가능 합니다 !) print(first*3) #hahahahahaha   상기의 예제는 문자열을 더하거나 곱하여서 새로운 문자열을 생성하는 것을 보았습니다.   앞으로 프로젝트를 진행하면서 받는 데이터들이 완벽한 문자열 혹은 문자로 받아진다면 저러한 연산은 필요없겠지만 저희가 앞으로 받은 데이터는 예상할 수 없는 데이터이기 때문에 항상 가공을 해야합니다.   문자열의 연산은 앞으로의 프로젝트에서 데이터를 처리하기위한 ‘첫걸음’ 정도로 생각하면 되겠습니다.   오늘은 파이썬의 문자열 연산에 대하여 알아보았습니다.  ","categories": ["Python"],
        "tags": ["Text sequence","Data Type","문자열","데이터타입","str","operation"],
        "url": "http://localhost:4000/python/Text-operation/",
        "teaser": "http://localhost:4000/assets/image/Text%20Operation.png"
      },{
        "title": "[Python] Text sequence (str Data Type)",
        "excerpt":"Text sequence (문자열, str)  오늘은 파이썬의 문자열 데이터 타입에 대하여 알아보겠습니다.   다른 언어는 문자와 문자열을 구분합니다. 문자는 한글자 예를들어 a 같이 단일 문자로 이뤄진 것을 의미합니다.   문자열은 두글자 이상으로 이루어진 문자열을 의미하며 apple, graph같은 단어를 의미합니다.   다른언어에서는 문자를 표현할때 ' ', 문자열을 표현할때는 \" \" 으로 표현합니다.   파이썬에서는 어떨까요? 하기 예제를 보면서 다른언어와 파이썬의 차이를 살펴보도록 하겠습니다.  a = 'Hello' b = \"K\" c = 'python'  print(a)  # Hello print(b)  # K print(c)  # python   상기 예제를 확인해보면 파이썬에서는 문자와 문자열을 표현할때 ' ' 와 \" \" 을 구분하지않고 사용이 가능합니다.   오늘은 파이썬의 문자열에 대하여 알아보았습니다.  ","categories": ["Python"],
        "tags": ["Text sequence","Data Type","문자열","데이터타입","str"],
        "url": "http://localhost:4000/python/Text-sequence/",
        "teaser": "http://localhost:4000/assets/image/Text%20Squence.png"
      },{
        "title": "[Python] Dictionary",
        "excerpt":"Dictionary  오늘은 파이썬의 Dictionary 에 대하여 알아보도록 하겠습니다.   Dictionary Key 와 Value의 쌍으로 이루어진 자료형 데이터 타입입니다.   Dictionary literal로 표현할 떄 { } 중괄호로 표현합니다.   Dictionary는 어떻게 표하는지 아래의 코드를 보며 알아보겠습니다.   my_dict = {} print(type(my_dict))  # &lt;class 'dict'&gt; my_dict = dict()      # 함수를 이용하여 딕셔너리를 제작 my_dict = {'a': '홍길동', 'b' : '강감찬'} my_dict['c'] = '신사임당' # 키와 값의 추가  print(my_dict) = {'a': '홍길동', 'b' : '강감찬', 'c' : '신사임당'}   몇가지 명령어를 통하여 Dictionary 구조에 대하여 한번 더 알아보겠습니다.   a = { \"name\" : \"홍길동\", \"age\" : 40, \"address\": \"서울\"} print(a.keys()) # dict_keys(['name', 'age', 'address']) // 리스트는 아님 print(type(a.keys())) #&lt;class 'dict_keys'&gt; print(list(a.keys())) # ['name', 'age', 'address'] print(a.values()) #dict_values(['홍길동', 40, '서울'])  print(a.items()) #dict_items([('name', '홍길동'), ('age', 40), ('address', '서울')])  # tuple로 표현   # for문을 돌리기 위해서 튜플로 변환 ( dict의 경우에는 for 문을 돌릴 수 없음)    오늘은 파이썬의 Dictionary 에 대하여 알아보았습니다.  ","categories": ["Python"],
        "tags": ["Sequence Type","Data Type","Dictionary"],
        "url": "http://localhost:4000/python/Dictionary/",
        "teaser": "http://localhost:4000/assets/image/List.png"
      },{
        "title": "[Python] Formatting",
        "excerpt":"In Not In 연산자  오늘은 파이썬의 문자열 의 Formatting 에 대하여 알아보도록 하겠습니다.   Formatting은 변수의 값을 원하는 곳에 입력하거나 출력이 가능합니다.   예제를 통하여 다시 한번 정확하게 알아보겠습니다.   num_of_apple = 10 myStr = \"나는 사과를 %d개 가지고 있어요!\" % num_of_apple #// %d (숫자) myStr1 = \"나는 사과를 {}, 바나나 {}개 가지고 있어요!\" .format(num_of_apple, 20) myStr2 = \"나는 사과를 {1}, 바나나 {0}개 가지고 있어요!\" .format(num_of_apple, 20) print(myStr) #나는 사과를 10개 가지고 있어요! print(myStr1) #나는 사과를 10, 바나나 20개 가지고 있어요! print(myStr2) # 나는 사과를 20, 바나나 10개 가지고 있어요!   복잡한 문장도 formatting 을 이용하여 원하는 위치에 변수의 값을 입력 및 출력을 할 수 있습니다.   오늘은 파이썬의 formatting 에 대하여 알아보았습니다.  ","categories": ["Python"],
        "tags": ["Text sequence","Data Type","문자열","데이터타입","str","formatting"],
        "url": "http://localhost:4000/python/Formatting/",
        "teaser": "http://localhost:4000/assets/image/Formatting.png"
      },{
        "title": "[Python] List",
        "excerpt":"List  오늘은 파이썬의 List 에 대하여 알아보도록 하겠습니다.   List는 임의의 객체(데이터)를 순서대로 저장하는 집합 자료형입니다.   List는 literal로 표현할 떄 [ ] 대괄호로 표현합니다.   List는 어떻게 표하는지 아래의 코드를 보며 알아보겠습니다.   my_list = [] print(type(my_list))  # &lt;class ‘list’&gt; my_list = list()      # 함수를 이용하여 리스트를 제작 my_list = [1, 2, 3]   # ~ : code convention _ 가독성이 좋게 표현하게 Hint 기능 제공 my_list = [1, 2, 3.14, \"Hello\", [5, 6, 7], 100] # 중첩리스트, 2차원이 아님    List는 문자열과 마찬가지로 Indexing 과 Slicing 모두 가능합니다. 물론 연산도 가능합니다.   Indexing과 Slicing의 개념이 궁금하신분들은 문자열 Indexing &amp; Slicing 편을 참고하시기 바랍니다.   간단한 예제를 통해서 자세하게 알아보겠습니다.   List의 Indexing 과 Slicing   print(my_list[1]) #2 print(my_list[-2]) #[5, 6, 7] print(my_list[4:5]) #[5, 6, 7] // list의 Slicing 은 list print(my_list[-2][1]) #6 print(my_list[0:2]) #[1, 2]   List의 연산  a = [1, 2, 3] b = [4, 5, 6] print (a + b) # [1, 2, 3, 4, 5, 6] list 의 합은 하나의 리스트로 생성 # 단 행렬에서의 연산은 [5,7,9] numpy에서 사용시 주의 할 것 print (a*3) # [1, 2, 3, 1, 2, 3, 1, 2, 3]  a = [1, 2, 3] a[0] = 5 print(a) # [5, 2, 3]  a[0] = [7, 8, 9] print(a) # [[7, 8, 9], 2, 3]  a[0:1] = [7, 8, 9] print(a) # [7, 8, 9, 2, 3]    list 값 추가 및 변경   List의 경우 값의 추가 및 변경이 가능합니다   # append   a = [1, 2, 3] a.append(4) 끝에 추가하는 것 print(a) #[1, 2, 3, 4] a.append([5, 6, 7]) print(a) #[1, 2, 3, [5, 6, 7]]  # sort   my_list = [\"홍길동\", \"아이유\", \"강감찬\", \"신사임당\", \"Kim\"] result = my_list.sort() # 리스트를 오름차순으로 정렬_ 1 2 3 4 5 print(result) # None    list 값 출력하기   List의 경우 값을 출력을 할 수 있습니다.   # for a = [1, 2, 3] print(a) #[1,2,3]  for i in a:   print(i) #1 #2 #3  print(''.join(str(a))) #123 문자열만 출력이 가능합니다! # '구분자'.join(인수 or list)    오늘은 파이썬의 List 에 대하여 알아보았습니다.  ","categories": ["Python"],
        "tags": ["Sequence Type","Data Type","List"],
        "url": "http://localhost:4000/python/List/",
        "teaser": "http://localhost:4000/assets/image/List.png"
      },{
        "title": "HTML CSS JAVASCRIPT",
        "excerpt":"    HTML CSS JAVASCRIPT 페이지   [Web Service] 기본이론   [JavaScript] jQuery 활용 1편   [JavaScript] jQuery 활용 2편  ","categories": ["HTML","CSS","JAVASCRIPT"],
        "tags": [],
        "url": "http://localhost:4000/html/css/javascript/Web-CSS-JAVASCRIPT/",
        "teaser": "http://localhost:4000/assets/image/frontend.png"
      },{
        "title": "[HTML, CSS, JS] jQuery 1",
        "excerpt":" jQuery  오늘은 jQuery 를 배워보겠습니다.   jQuery는 JavaScript로 만든 사용하기 편한 무료 라이브러리 입니다.   JavaScript는 특정 browser 제대로 작동하지 않는 경우가 있습니다.   그렇지만 jQuery의 경우 모든 browser 에서 동일하게 작동합니다.    jQuery 사용방법   설치도 가능하지만 CDN방식을 이용하려고 합니다.   CDN(Content Delivery Network) 방식은 네트워크를 통해서 라이브러리를 동적으로 다운로드해서 사용하는 개념입니다.   하기코드는 jQuery사이트에서 직점 복사할 수 있습니다.       &lt;script             src=\"https://code.jquery.com/jquery-2.2.4.min.js\"             integrity=\"sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=\"             crossorigin=\"anonymous\"&gt;&lt;/script&gt;    jQuery 첫걸음   그렇다면 jQuery 사용하여 보도록 하겠습니다.   jQuery는 공부할때 가장먼저 배워야하는 것은 바로 Selector 입니다.   하기 예제를 통하여 Selector에 대하여 자세하게 알아보겠습니다.   HTML      &lt;script src=\"js/05_jQuery.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;h1&gt;jQuery 연습입니다.!!&lt;/h1&gt;     &lt;div&gt;          &lt;ul&gt;             &lt;!--class는 중복해서 사용가--&gt;             &lt;li class=\"region\"&gt;서울&lt;/li&gt;             &lt;!--ID 는 중복해서 사용 불가능--&gt;             &lt;li id=\"haha\"&gt;인천&lt;/li&gt;             &lt;li class=\"region\"&gt;강원&lt;/li&gt;         &lt;/ul&gt;         &lt;ol&gt;             &lt;li id=\"hong\"&gt;홍길동&lt;/li&gt;             &lt;li&gt;신사임당&lt;/li&gt;             &lt;li&gt;강감찬&lt;/li&gt;         &lt;/ol&gt;     &lt;input type=\"button\" value=\"클릭클릭!\" onclick=\"my_func()\"&gt;     &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;   상기 코드에서 ‘클릭클릭’이라는 버튼을 누르면 my_func()라는 함수가 호출됩니다.   my_func()는 HTML에서 명시한 것 처럼 js/05_jQuery.js 에 위치하고 있습니다.   my_func()를 살펴보도록 하겠습니다.   function my_func() {     alert(\"함수가 호출되요\") // print 기능으로 활용가능합니다!     1. 전체 선택자(universal selector)     $(\"*\").css(\"color\",\"red\") // * 전체선택자     $(\"*\").text() // 태그안에 모든 글자를 가져옵니다     2. 태그 선택자(tag selector)     $(\"li\").remove() // li 테그를 모두 삭제합니다. 인자와 항목까지 전부삭제          3. 아이디 선택자(id selector)  중복하여 사용불가능     $(\"#haha\").text()  // # ID지칭                         // 인자가 없으면 값을 알아오라는 의미, 인자가 있으면 값을 변경     $(\"#haha\").text(\"울산\")          4. 클래스 선택자 (class selector) 중복하여 사용가능     $(\".region\").css(\"background-color\", \"yellow\")          5. 구조 선택자 (자식 선택자 후손 선택자)     $(\"ol &gt; *\").remove() // ol &gt; * ol에 자식으로 있는 것들 중 모든것     $(\"ol &gt; li\").css(\"color\", \"blue\") // ol &gt; * ol에 자식으로 있는 것들중 li      $(\"div li\").css(\"color\", \"pink\")    // div 후손으로 있는 것들 중  li를 모두 선택          6. 구조 선택자 (형제 선택자)     $(\"#haha + li\").css(\"color\", \"pink\")  // id의 형제를 찾고 +를 이용하여 바로 다음 형제를 찾는 것이 가능     $(\"#hong ~ li\").css(\"color\", \"pink\")  //id 이후의 모든 형제를 찾음 (자신제외)          7. 속성 선택자     $(\"[id]\").css(\"color\", \"yellow\")  // id 모든 속성을 전부 찾음     $(\"[class]\").css(\"color\", \"red\")     // class 모든 속성을 전부 찾음          // 이 7가지를 조합하면 왠만한 element는 지정하는게 가능 !!!!   상기 코드에 주석을 처리하여 어떤 element 를 지정하는지 알아보았습니다.  ","categories": ["HTML","CSS","JAVASCRIPT"],
        "tags": ["JQuery"],
        "url": "http://localhost:4000/html/css/javascript/jQuery/",
        "teaser": "http://localhost:4000/assets/image/frontend.png"
      },{
        "title": "[HTML, CSS, JS] jQuery 2",
        "excerpt":" jQuery  오늘은 jQuery 를 배워보겠습니다.   jQuery는 JavaScript로 만든 사용하기 편한 무료 라이브러리 입니다.   JavaScript는 특정 browser 제대로 작동하지 않는 경우가 있습니다.   그렇지만 jQuery의 경우 모든 browser 에서 동일하게 작동합니다.    jQuery 사용방법   설치도 가능하지만 CDN방식을 이용하려고 합니다.   CDN(Content Delivery Network) 방식은 네트워크를 통해서 라이브러리를 동적으로 다운로드해서 사용하는 개념입니다.   하기코드는 jQuery사이트에서 직점 복사할 수 있습니다.       &lt;script             src=\"https://code.jquery.com/jquery-2.2.4.min.js\"             integrity=\"sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=\"             crossorigin=\"anonymous\"&gt;&lt;/script&gt;    jQuery 첫걸음   그렇다면 jQuery 사용하여 보도록 하겠습니다.   jQuery는 공부할때 가장먼저 배워야하는 것은 바로 Selector 입니다.   하기 예제를 통하여 Selector에 대하여 자세하게 알아보겠습니다.   HTML      &lt;script src=\"js/05_jQuery.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;h1&gt;jQuery 연습입니다.!!&lt;/h1&gt;     &lt;div&gt;          &lt;ul&gt;             &lt;!--class는 중복해서 사용가--&gt;             &lt;li class=\"region\"&gt;서울&lt;/li&gt;             &lt;!--ID 는 중복해서 사용 불가능--&gt;             &lt;li id=\"haha\"&gt;인천&lt;/li&gt;             &lt;li class=\"region\"&gt;강원&lt;/li&gt;         &lt;/ul&gt;         &lt;ol&gt;             &lt;li id=\"hong\"&gt;홍길동&lt;/li&gt;             &lt;li&gt;신사임당&lt;/li&gt;             &lt;li&gt;강감찬&lt;/li&gt;         &lt;/ol&gt;     &lt;input type=\"button\" value=\"클릭클릭!\" onclick=\"my_func()\"&gt;     &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;   상기 코드에서 ‘클릭클릭’이라는 버튼을 누르면 my_func()라는 함수가 호출됩니다.   my_func()는 HTML에서 명시한 것 처럼 js/05_jQuery.js 에 위치하고 있습니다.   my_func()를 살펴보도록 하겠습니다.   function my_func() {     alert(\"함수가 호출되요\") // print 기능으로 활용가능합니다!     1. 전체 선택자(universal selector)     $(\"*\").css(\"color\",\"red\") // * 전체선택자     $(\"*\").text() // 태그안에 모든 글자를 가져옵니다          2. 태그 선택자(tag selector)     $(\"li\").remove() // li 테그를 모두 삭제합니다. 인자와 항목까지 전부삭제          3. 아이디 선택자(id selector)  중복하여 사용불가능     $(\"#haha\").text()  // # ID지칭                         // 인자가 없으면 값을 알아오라는 의미, 인자가 있으면 값을 변경     $(\"#haha\").text(\"울산\")          4. 클래스 선택자 (class selector) 중복하여 사용가능     $(\".region\").css(\"background-color\", \"yellow\")          5. 구조 선택자 (자식 선택자 후손 선택자)     $(\"ol &gt; *\").remove() // ol &gt; * ol에 자식으로 있는 것들 중 모든것     $(\"ol &gt; li\").css(\"color\", \"blue\") // ol &gt; * ol에 자식으로 있는 것들중 li      $(\"div li\").css(\"color\", \"pink\")    // div 후손으로 있는 것들 중  li를 모두 선택          6. 구조 선택자 (형제 선택자)     $(\"#haha + li\").css(\"color\", \"pink\")  // id의 형제를 찾고 +를 이용하여 바로 다음 형제를 찾는 것이 가능     $(\"#hong ~ li\").css(\"color\", \"pink\")  //id 이후의 모든 형제를 찾음 (자신제외)          7. 속성 선택자     $(\"[id]\").css(\"color\", \"yellow\")  // id 모든 속성을 전부 찾음     $(\"[class]\").css(\"color\", \"red\")     // class 모든 속성을 전부 찾음          // 이 7가지를 조합하면 왠만한 element는 지정하는게 가능 !!!!   상기 코드에 주석을 처리하여 어떤 element 를 지정하는지 알아보았습니다.  ","categories": ["HTML","CSS","JAVASCRIPT"],
        "tags": ["JQuery"],
        "url": "http://localhost:4000/html/css/javascript/jQuery2/",
        "teaser": "http://localhost:4000/assets/image/frontend.png"
      },{
        "title": "[HTML, CSS, JS] Web Basic",
        "excerpt":" Web 기초   1. Internet   여러개의 컴퓨터를 network로 묶어서 사용하는 것은 LAN (Local Area Network) 입니다.   Internet 이란 쉽게 설명하여 전세계적인 Network를 즉 물리적인 네트워크 망을 지칭합니다.   2. Service   인터넷을 잘 이용하기 위해서는 인터넷 위에 여러가지 프로그램이 동작하여야 합니다. 이런 프로그램을 Service라고 합니다. 쉬운 예로 하기의 서비스가 있습니다.     Email (SNTP)     Torrent     Web service    여기서 웹서비스는 HTML, CSS, JavaScript를 이용해서 웹페이지를 만들고   web서버가 이 web page를 web client에게 전송해서 데이터르 주고 받는 서비스 입니다.   3. CS 구조   Client - Server 구조를 의미합니다.   Web Client - Web Server 프로세스 단위로 나눔, 프로그램 단위로 나눔   Web Client(Web Browser - Chrome, IE, Edge, Safari, Firefox, Opera)   Web Server : 데이터를 제공하는 역할을 하는 process (프로그램) Apache web server   Web Server에서 제공되는 데이터는 Web page 형태로 제공되는 데이터 Web Application 형태로 제공되는 데이터   HTML, CSS, JavaScript 언어로 이 데이터를 만들어서 제공합니다.   4. 기본적인 Web Service                  정적 웹 서비스 (Static Web Service) : HTML, CSS, JS 클라이언트가 특정 HTML 파일을 요청                  동적 웹 서비스 (Dynamic Web Service) : HTML, CSS, JS + Python, Java, C++            5. 개발환경 세팅   Pycharm을 이용해서 작성해 보겠습니다.   6. 예제 작성    &lt;!DOCTYPE html&gt;  &lt;html lang=\"en\"&gt;     &lt;head&gt;     &lt;!-- 일반적인 설정이 와요!! --&gt;         &lt;meta charset=\"UTF-8\"&gt;         &lt;title&gt;Title&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;        &lt;!-- BROWSER에 출력하고 싶은 내용이 와요!! --&gt;        &lt;h1&gt; 이것은 소리없는 아우성!! 껄껄 &lt;/h1&gt;     &lt;!-- heading 글자크기를 크게 // 문장전체 : element, &lt;&gt; : tag--&gt;        &lt;img src=\"image/download.jpg\"&gt;        &lt;!-- img src 그림을 삽입 // property--&gt;        &lt;!-- element, tag, property --&gt;     &lt;/body&gt; &lt;/html&gt;    Web 서버가 web 클라이언트에게 제공할 HTML을 만들었습니다.   전제조건 및 html을 실행하는 과정은 아래와 같아요.      웹서버가 일단 존재해야 해요     웹서버가 내가 작성한 프로젝트를 인식해야해요!! &gt; configure     웹서버프로그램을 기동(실행)하면 자신이 인식하고 있는 프로젝트를 웹에서 사용할 수 있도록 deploy(전개)해요!!     클라이언트가 접속할 서버 컴퓨터의 IP와 포트번호를 정하게 되요!     웹클라이언트를 실행해야해요!! - chrome을 실행해요!!     크롬을 이용해서 웹서버에 접속해서 우리가 작성한 HTML파일을 받아와요!     크롬브라우저가 받은 html을 해석해서 화면을 그려요!! (rendering)    7. HTML VS CSS VS JS      HTML : tag로 구성이 되요! 문서의 구성, 구조(DOM_Document object model)과 내용을 담당     CSS : 문서의 style을 담당     JavaScript : 문서의 동적처리를 담당    ","categories": ["HTML","CSS","JAVASCRIPT"],
        "tags": ["Web"],
        "url": "http://localhost:4000/html/css/javascript/web-basic/",
        "teaser": "http://localhost:4000/assets/image/frontend.png"
      },{
        "title": "Django Page",
        "excerpt":" \t   Django 페이지   [Djanggo] 기초이론   [Djanggo] 설치 및 운용   [Djanggo] Poll project1   [Djanggo] Poll project2   [Djanggo] Poll project3 마무리    [Django] 게시판 만들기(BBS 프로젝트)   ","categories": ["Django"],
        "tags": [],
        "url": "http://localhost:4000/django/DjangoPage/",
        "teaser": "https://live.staticflickr.com/3595/3475465970_7044242629_b.jpg"
      },{
        "title": "[Django] BBS Project ",
        "excerpt":" BBS (Bullentin Board System)   Poll 프로젝트에 이어 오늘은 게시판을 만들어 보겠습니다.   Poll 프로젝트는 처음 부터 끝까지 저희가 코드를 작성했었죠 ?   외울 것도 많고 작성해야하는 것도 많았습니다.   오늘은 polls project 에서 배웠던 내용을 기반으로 쉽게 제작해보겠습니다.   ModelForm을 이용해서 CRUD구현을 알아 보겠습니다.   CRUD (CREATE READ UPDATE DELETE)   기존방식으로 models에서 정의한 테이블에 값을 넣기가 정말 어려웠습니다.   하지만 ModelForm을 이용하면 사용자 입력양식 처리하는게 쉬워집니다.   여기에 html 프로젝트에서 사용하였던 Bootstrap도 포함해서 자동으로   만들어진 component를 통해 Web application을 만들어 보겠습니다.      필요한 package들을 설치해야해요!   기본적으로 Django를 설치해야합니다.     $ pip3 install Django    추가적으로 bootstrap에 대한 package를 설치합니다.   일반적인 HTML 파일을 만들고 Bootstrap을 CDN과 tag 속성을 이용하면 Bootstrap을 이용할 수 있어요!   그런데 이번에는 ModelForm을 이용할 것이고 사용자 입력양식 HTML을 자동으로 만들어줘요   자동으로 생성되기 떄문에 Bootstrap을 적용할수 없어요.   이런경우에 사용자 입력양식에 Bootstrap을 적용하기 위해서 특정 Package를 설치해야 해요!      $ pip3 install Django-bootstrap4    이렇게 하면 model form으로도 Bootstrap 테마를 적용 할 수 있습니다.      project를 생성 + application 생성   Django는 framework 이고 당연히 scaffolding 기능을 제공합니다.   특정 명령어를 이용해서 필요한 폴더와 파일을 자동으로 생성해야 합니다.   터미널을 이용해서 working directory를 python-django 폴더로 변경해요!!   $ django-admin startproject blog   해당 명령을 실행하면 기본적인 프로젝트 구조가 만들어져요   우리 프로젝트와 앞으로 생성할 application 을 포함하고 있는 폴더의 이름을 변경합니다   파일명이 혼동여부가 있어 상위폴더이름을 MyBlogSystem으로 파일명을 변경합니다.   하나의 application을 우리프로젝트에 추가해요!!   python3 manage.py startapp posts      project 설정 (settings) app등록  bootstrap도 마찬가지로 application 등록을 해야함.   bootstrap4 등록!!   settings.py 에 APP을 추가합니다.   INSTALLED_APPS = [     'django.contrib.admin',     'django.contrib.auth',     'django.contrib.contenttypes',     'django.contrib.sessions',     'django.contrib.messages',     'django.contrib.staticfiles',     'posts.apps.PostsConfig',     'bootstrap4' ]   Templates 에서 DIRS를 추가 경로지정가능 !          'DIRS': [os.path.join(BASE_DIR, 'blog', 'templates')],   맨아래 내려가서 하기코드도 추가합니다. static이라는 폴더에 바로접근할 수 있습니다.   정적리소스를 사용가능합니다.   STATICFILES_DIRS = [     os.path.join(BASE_DIR, 'static') ]      우리의 project를 web에 deploy해봐야 해요 !! 기본적인 데이터 베이스를 들고가야해서 무조건 사용자 등록을 해야합니다.   admin page가 존재 web에 deploy하기 이전에.. 기본 table부터 생성해야해요!     python3 manage.py migrate    관리자 계정이 있어야 Admin page(관리자 화면)를 사용할 수 있어요!     python3 manage.py createsuperuser    설정을 다했으니 이제 Web에 deploy해보도록 하겠습니다.     python3 manage.py runserver      프로젝트의 기본설정이 완성 되었습니다.      모델구현 기능을 구현하러 가야해요!! application을 구현해야해요!   기능을 구현할 때 제일먼저해야 하는 일은 사용할 데이터에 대한 정확한 명세를 작성하는 거에요!!   Django는 ORM을 이용하기 떄문에 class를 이용해서 Database를 사용해요!   Model을 만들어야해요!! posts / applicaiton / models.py 파일에 Model을 정의   CharField vs TextField  한줄 vs 여러줄   이렇게 내가 만든 model을 Admin page에 반영하기 위해서   admin.py에 class를 등록해야해요!!   Model을 생성했기 떄문에 데이터베이스에 변경이 필요!   데이터베이스를 이렇게 저렇게 변경하세요 라는 명세(초안) 가 필요!!     python3 manage.py makemigrations    초안이 완성되면 실제로 데이터베이스에 적용해서 Table을 생성     python3 manage.py migrate    초기화 하기위해서는 migrations 폴더에 initial.py 와 db.sqlite3를 전부다 지우면됨!      URL 경로 설정   from django.contrib import admin from django.urls import path, include from django.conf.urls import url from django.views.generic.base import TemplateView   htttp:// localhost:8000 요청이 들어왔을때 우리 전체 project의 홈페이지로 이동할거에요!!   Django는 elegant URL을 지원해요. 정규표현식을 지원합니다.   정규표현식 (regualr expression)   시작 &gt; ^, 끝 &gt; $   [0-9] : 1글자를 지칭   {} : 반복횟수 {3} 3번반복 {3,5} 3 아님 5번 반복   [0-9]{4} : 4자리 숫자가 나옴   r(raw) 은 escape 문자를 한번 더 사용하지 않도록 처리.   r”^[0-9]{1,3}$” 숫자가 1개나 3개나 모두가능   \\d 숫자를 지칭   r”^010[1-9]\\d{7,8}$”   urlpatterns = [     # view 를 거치지 않고 바로 html을 호출     url(r”^$”, TemplateView.as_view(template_name=’index.html’), name=”home”),     path(‘admin/’, admin.site.urls),     # path(‘posts/’, include(‘posts/urls’)) ]   cdn 방식으로 bootstrap을 써봐요 !! cover의 소스를 끌고와요 F12 개발자모드에서 소스끌어오기! static /css 에 붙여넣기   url 설정 복붙하고 app_name = posts’   urlpatterns = [     path(‘list/’, views.p_list, name = ‘list’), ]   blog project 안에 urls.py 부터 설정   post application 안에 url.py 설정   base template html 파일ㅇ르 blog project 안에 templates 폴더안에 생성      ModelForm 생성 사용자 입력양식을 우리가 직접 HTML template안에 입력하는게 아니라 Model을 기반으로 사용자 입력양식을 자동으로 생성해 줄 수 있는데 ModelForm을 이용하면 이 작업을 할 수 있어요 !!   class를 작성해야 해요 ! &gt; 어느파일에서 만들어야 하나요??   forms.py 에서 정의해야해요!   from django import forms from posts.models import Post   class PostForm (forms.ModelForm):     class Meta:         model = Post         fields = [‘author’, ‘contents’]      list page 생성            views.py 을 수정해서 list/ 가 요청되었을 때 해야하는 일을 기술           from django.shortcuts import render from posts.models import Post  Create your views here.   def p_list(request):    #데이터     my_list = Post.objects.all().order_by(‘-id’)     context = {‘posts’ : my_list}     return render(request, ‘list.html’, context)   posts/ list.html   전부 다 작성할필요가없어요 base.html의 것을 확장해서 사용   { % extends ‘base.html’ % }   { % block container % }     &lt;div class ='container'&gt;         &lt;h1&gt;Bullentin Board System(BBS)&lt;/h1&gt;   &lt;/div&gt; { % endblock % }   안에 좀더 내용을 채워봐요 !!           create page 생성            delete 기능 구현      ","categories": ["Django"],
        "tags": ["Polls","Project","Webapplication","BBS"],
        "url": "http://localhost:4000/django/Django-BBS/",
        "teaser": "https://live.staticflickr.com/3595/3475465970_7044242629_b.jpg"
      },{
        "title": "[Django] 이론",
        "excerpt":"Django  오늘은 Django에 대하여 알아보아요! Python 으로 만들어진 오픈소스 웹 어플리케이션을 쉽게 작성할 수 있도록 도와주는 Framework   라이브러리(library)  특수한 처리를 하기 위해서 만들어 놓은 함수집합이 Library입니다. jQuery도 라이브러리라고 볼 수 있어요!   장점 : 내가 모든걸 다 작성할 필요가 없어요!   단점(특징) : 전체 프로그램의 로직을 담당하지는 않아요!   예) jQuery 를 이용해서 영화정보를 출력하는 문제를 구현할 때 사람마다 구현이 제각각…   프레임 워크  프로그램의 전체적인 로직부분이 이미 구현이 되어 있어요!   그래서 프레임워크를 사용할때는 기본적으로 사용되는 코드가 제공되요! (스케폴딩- scaffolding)   유지보수성이 좋아집니다. 단, 처음에 프레임워크의 동작원리를 이해하는 작업이 필요!!      Django를 이용하면 Web Application에서 많이 자주 구현해야 하는 내용을 쉽게 구현할 수 있어요!   라이브러리(library) VS 프레임워크  두 가지 모두 이미 만들어진 것을 사용하는 것은 동일합니다. 차이점은 규칙에 있습니다. 라이브러리는 가져다 쓰는 개념이고 프레임워크는 내 것을 가져다가 프레임 워크 규칙에 맞추는 개념입니다.    데이터 베이스   Database : 데이터의 집합체   DBMS (Database Management System)   데이터베이스를 구축하고 원하는 정보를 추출하고 새로운 데이터를 입력하고 기존데이터를 삭제하고 기존데이터를 수정하는 작업을 진행.   Django에서는 sqlite3라는 DBMS를 default 로 사용합니다.   이런 데이터베이스는 언제부터 사용됐을까요? 초창기에는 데이터를 이렇게 관리하면 좋지않을까라고 생각했습니다. 그래서 나온 것이 조직도 형상 트리 구조로 정의된 계층형 데이터 베이스입니다.   하지만 IBM에서 Relation 이라는 논문을 발표하였고 DB2를 출시하였습니다.   관계형 데이터베이스는 행과 열로 구성된 테이블 간의 관계를 나타내는 것입니다.                  관계형 데이터베이스                                                  순번                               이름                               학과                                                       1                               홍길동                               심리학과                                                 2                               김길동                               컴퓨터학과                                                 3                               신사임당                               경제학과                                                 …                               …                               …                   데이터를 관리하기 편한 장점을 가지고 있어 현재에는 거의 모든 DBMS가 Relational Database(관계형 데이터베이스)으로 제작됩니다.   테이블 자료를 끌어가야하는데 프로그램 방식은 크게 두가지 방식이 있습니다.     ODBC   ORM (Object Relation Mapping) # Django   즉 쉽게 설명하자면 Table = relation = class와 매핑됩니다.     Django의 특징  Django는 MVC Model을 기반으로 한 MVT model을 이용해요!   MVC Model : Model, View, Controller   MVT model : Model, View, Template   model : 데이터베이스 처리   View : 로직을 담당   Template : 클라이언트에게 보여줄 화면을 담당   오늘은 파이썬의 Django의 이론에 대하여 알아보았습니다.  ","categories": ["Django"],
        "tags": [],
        "url": "http://localhost:4000/django/Django-Basic/",
        "teaser": "https://live.staticflickr.com/3595/3475465970_7044242629_b.jpg"
      },{
        "title": "[Django] 설치 및 기초운용",
        "excerpt":"Django설치 및 기초운용  Django 설치  mac 기반으로 작성하였으니 참고하시기 바랍니다. python 실행경로를 꼭! 확인해 주세요.   pip(python install package), pypi(python Package Index)라는 repository에 있는 Django를 설치합니다.   가상환경에서 설치  가상환경에서 하실분은 하기 내용을 추가하여 설치해주시기 바랍니다.                  가상환경(virtualenv) 설치 : $ python3 -m venv posts                  가상환경 실행(virtualenv) : $ source posts/bin/activate                  설치된 패키지 확인 : $ pip3 freeze            Django 설치  가상환경이 아닌 로컬에서 설치하실 분들은 이쪽부터 진행 하시면 됩니다.                  Django 설치 : '$ pip3 install django                  python 3.7.8버전을 사용하시는 분은 pip3를 update를 해주셔야 합니다.                  pip upgrade : $ pip3 install --upgrade pip                  여기까지 하시면 설치가 완료가 됩니다.             Project Setup   본격적으로 프로젝트의 뼈대를 만드는 일부터 시작하겠습니다.    터미널에서 설정                  폴더 생성 : $ mkdir python-Django                  만들어진 경로로 이동 : $ cd python-Django                  mysite 프로젝트 생성 및 Scaffolding : $ django-damin startproject mysite                  폴더명 변경(선택사항) :python-Django/myself 이름을 MyFirstWebPoll로 변경                  변경된 경로로 이동 : $ cd MyFirstWebPoll                  프로젝트 안에 개별 어플리케이션을 생성 :$ python3 manage.py startapp polls                  poll 이라는 어플이 생성되고 필요한 파일들이 scaffolding 됨             Python 설정변경 [pycharm 사용]                   pycharm에서 MyFirstWebPoll 프로젝트 실행                  setting.py를 이용해 프로젝트 설정처리                  기본테이블(기본DB)을 생성                  장고는 관리자 모드 화면을 제공                  관리자 ID PW가 DB어딘가에는 저장이 되어 있어야함 (DB설정이 전제됨)                  INSTALLED_APPS 리스트 항목에 ‘polls.apps.PollsConfig’ 를 추가                  TIME_ZONE ‘Asia/Seoul’ 로 변경            # Application definition   INSTALLED_APPS = [     'django.contrib.admin',     'django.contrib.auth',     'django.contrib.contenttypes',     'django.contrib.sessions',     'django.contrib.messages',     'django.contrib.staticfiles',     'polls.apps.PollsConfig' ]  …  # Internationalization # https://docs.djangoproject.com/en/3.0/topics/i18n/  LANGUAGE_CODE = 'en-us'  TIME_ZONE = 'Asia/Seoul'  USE_I18N = True  USE_L10N = True  USE_TZ = True    urls.py 수정    from django.contrib import admin from django.urls import path, include  urlpatterns = [     path('admin/', admin.site.urls),     path('polls/', include('polls.urls')) ]    프로젝트 Deploy                 터미널을 이용해서 내장 서버를 이용하여 프로젝트를 deploy 해보도록 하겠습니다.                  프로젝트 migrate : python3 manage.py migrate                  서버 실행 : python3 manage.py runserver                  관리자 설정 : python3 manage.py createsuperuser #user, email, pw 설정                  서버실행 : python3 manage.py runserver                  127.0.0.1:8000 로 접속                  Polls application 구현확인               Model 생성   Model 작업은 우리가 사용하는 Database에 Table을 생성하는 작업이에요!   (Table == Relation) 즉 class의 이름은 결국 table의 이름과 mapping이 되요   application 에서 사용할 데이터베이스 구조를 생각하고 입력해보겠습니다.   models.py 안에 모든 모델들을 정의해요 !!   from django.db import models  # Create your models here. class Question(models.Model): # Django 가제공하는 models 클래스     question_text = models.CharField(max_length=200)    #문자열을 받고 길이는 200자 까지     pub_date = models.DateTimeField('date published')      def __str__(self):      # 일반적으로 연산을 위해서 문자열로 변환을 하고 싶을때!         return self.question_text  class Choice(models.Model):     # question_id = models.ForeignKey(Question, on_delete=models.CASCADE)     # 기본적으로 _id가 자동으로 붙음     question = models.ForeignKey(Question, on_delete=models.CASCADE)     # 만약에 Question 에 대하여 지운다면 같이 지운다 CASCADE 문제없이 만드는 것      choice_text = models.CharField(max_length=200)     votes = models.IntegerField(default=0)      def __str__(self):         return self.choice_text      # def __repr__(self):     # class 의 객체를 문자열로 표현할 경우에 사용      # Table의 id column은 default로 지정되요!!!     # id가 primary key로 설정이 가능!, Not null (값이 무조건 들어가는 경우), Unique (겹치는 값이 안옴)     # id는 autoincrement 특성(값이 들어오면 자동적으로 증가하는 특성)을 가지는 정수형으로 지정     # 자동으로 생성해주기 때문에 class정의에서 나오지 않아요!!     model 및 파일등록      admin.py 파일에 등록해요       admin page에서 사용할 수 있도록 등록을 해줘야해요!!       /polls/admin.py 에서 하기 코드를 추가합니다.    from polls.models import Question, Choice # Register your models here.  #괄호안에는 내가 등록할 클래스가 나와야해요! admin.site.register(Question) admin.site.register(Choice)   여기까지는 작업했다고해서 실제 데이터베이스 테이블이 생선되는건 아니에요!!   하기 과정을 통하여 표를 삽입을 해줘야합니다.      python3 manage.py makemigrations          class와 매핑되는 테이블을 만들기 위해서 필요한 SQL 구문을 생성해야 되요!!        python3 manage.py migrate          그리고 나서 이 구문을 실행해서 실제 테이블을 생성해야 해요!        python3 manage.py runserver          프로젝트가 web에 deploy 될 수 있는지를 확인합니다.       관리자 페이지가 정상적으로 동작하는지 확인하기 위해서 서버를 기동 !           127.0.0.1:8000 로 접속    완료하면 하기 그림처럼 초기 설정 화면은 얻을수 있습니다.    ","categories": ["Django"],
        "tags": ["Install","Webapplication"],
        "url": "http://localhost:4000/django/Django-simple-web-application/",
        "teaser": "https://live.staticflickr.com/3595/3475465970_7044242629_b.jpg"
      },{
        "title": "[Django] Poll 프로젝트 1",
        "excerpt":"Polls 프로젝트 1  Templates 생성  저번시간에는 기본뼈대까지 생성하였으며 투표를 하기위한 질문과 선택지를 데이터베이스에 저장해보았습니다.   이번 시간에는 데이터베이스에 있는 데이터를 활용해보도록 하겠습니다.   투표 프로젝트를 만들면서 자세하게 알아보겠습니다.   일단 터미널에서 polls폴더 안에 template 폴더를 생성합니다.      $ cd polls      $ mkdir templates     Pycharm을 다시한번 열어보겠습니다.   만들어진 template 폴더안에 index.html 파일을 생성합니다.   생성하는 이유는 차근차근 설명하도록 하겠습니다.   어제 만든 models.py 안에 저희가 Class Question 과 Choice 를 만들었죠?   오늘은 어제 만든 Class를 사용하여 만들어보도록 하겠습니다.   polls폴더안에 views.py파일을 실행시켜 하기 코드를 추가합니다.    def index(request): # 서버가 보내준 request 반드시 인자로 넘겨줘야함 !!     #로직처리 코드가 나와요!!     tmp = Question.objects.all().order_by('-pub_date')[:3]     # 객체(objects)의 모든것(all())을 불러옴 정렬 order_by() - 오름차순 [:] slicing     context = {\"latest_question_list\" : tmp}     return render(request, 'index.html', context)     #render는 그리는 작업 / HTML을 그림    코드설명     서버와 클라이언트 사이에는 request와 response로 데이터를 주고 받습니다.      index(request) : 서버에서 받은 request를 index 함수에 인자로 넘겨줍니다.     tmp라는 변수를 설정하여     Question : Question Class     objects : 클래스 안의 객체     all() : 전부     order_by('-pub_date') : pub-date 기준으로 오름차순으로     [:3] : Slicing 3개까지 변수로 할당합니다.     context     dictionary 형태를 통하여 변수 context를 선언합니다.     latest_question_list는 Key값  Question 의 모든객체는 Value 값이 됩니다.     render : request 를 받아 함수처리를 하고 html파일에 적용하는 것을 의미합니다.      다음은 urls.py 파일을 생성해보겠습니다.   처음부터 새로 만들어도 가능하지만 mysite에서 만들어진 urls.py를 polls하위에 복사하여 사용하도록하겠습니다.   모든내용을 지우고    from django.urls import path from . import views  app_name = \"polls\"  urlpatterns = [     # http://localhost:8000/polls/     path('', views.index, name='index'),  ]    코드설명     from . import views 경로안에 views.py 함수를 사용합니다.   path(‘’, views.index, name=’index’), localhost:8000/polls/ 경로뒤에 ‘’ 아무것도 오지않으면 view.index 함수호출해요 name 은 경로에 대한 이름 입니다. 향후 이름을 통해서 경로를 호출하거나 함수를 사용할 수 있습니다.     다시 처음으로 돌아가서 index.html의 코드를 수정하겠습니다.  &lt;body&gt;     &lt;h1&gt;투표목록이 나와야 해요!!&lt;/h1&gt;      { % if latest_question_list % }         &lt;ul&gt;         { % for question in latest_question_list % }             &lt;li&gt;&lt;a href=\"/polls/{ { question.id } }\"&gt;                     { { question.question_text } }&lt;/a&gt;&lt;/li&gt;         { % endfor % }         &lt;/ul&gt;     { % else % }         &lt;p&gt;출력할 투표목록이 존재하지 않습니다.&lt;/p&gt;     { % endif % } &lt;/body&gt;   코드설명     template code!! python도아니고 HTML 도아닌 template 안에서만 사용가능  중괄호 표현은 template code이며 HTML, Python 언어가 아니므로 주의하셔서 사용해야합니다.      { % % } : 로직코드이며 조건 및 반복문 등 로직을 사용해야할 경우 사용합니다.     { { } } : 값을 입력할 경우 사용합니다.     { { if latest_question_list} }     views.index에서 키값으로 받은 latest_question_list 존재여부를 판단합니다.        { { for question in latest_question_list} }     question 변수에 lastest_question_list객체를 삽입합니다.        &lt;li&gt;&lt;a href=\"/polls/{ { question.id } }\"&gt;{ { question.question_text } }&lt;/a&gt;&lt;li&gt;     lastest_question_list 에서 전달받은 객체에서 .question_text 객체를 뽑아냅니다.      이렇게하면 하기의 초기페이지를 완성할 수 있습니다.          오늘은 첫페이지인 index까지 작성해 보았습니다.  ","categories": ["Django"],
        "tags": ["Polls","Project","Webapplication"],
        "url": "http://localhost:4000/django/Django-simple-web-application2/",
        "teaser": "https://live.staticflickr.com/3595/3475465970_7044242629_b.jpg"
      },{
        "title": "[Django] Poll 프로젝트 2",
        "excerpt":"Polls 프로젝트 2  투표시스템 질문지 항목 추가  저번시간에는 Question 항목까지 만드는 것을 해보았습니다.   이번 시간에는 선택항목까지 제작해보도록 하겠습니다.   Pycharm을 다시한번 열어보겠습니다.   만들어진 template 폴더안에 detail.html 파일을 생성합니다.   생성하는 이유는 차근차근 설명하도록 하겠습니다.   첫 시간에 models.py 안에 저희가 Class Question 과 Choice 를 만들었죠?   오늘도 만든 Class를 사용하여 만들어보도록 하겠습니다.   polls폴더안에 views.py파일을 실행시켜 하기 코드를 추가합니다.    def detail(request, question_id):     # 로직처리를 해요!     # 아까는 모든 Question 객체를 다 구해서 리스트로 만들었는데     # 이번에는 특정 Question 객체 1개만 구해야 해요     tmp = get_object_or_404(Question, pk=question_id)     context = {\"question\" : tmp} # questiond 이라는 문자열로 context를 호출합니다.     return render(request, 'detail.html', context)    코드설명     index method를 제작했을 때와는 다르게 처음보는 코드가 있습니다.      def detail(request, question_id):     def index 에서 와는다르게 question_id 라는 인자를 하나 더받습니다.     index에서 하이퍼링크를 타고 detail 페이지로 넘어올때 그 인자까지도 받는다는 내용입니다.     get_object_or_404(Question, pk=question_id)     받는 객체가 있다면 객체를 받고 없다면 404 page를 띄운다는 간단한 내용입니다.     대신 전달받은 primary key에 한해 Question에서의 객체를 받는 다는 내용입니다.      다음은 urls.py 파일을 생성해보겠습니다.      http://localhost:8000/polls/ 주소로 접속하면 index.html 로 들어가게 되어있습니다.     저희는 질문지를 눌렀을때 선택항목이 나오는 페이지가 나오게 경로를 잡아줘야합니다.     다양한 방법이 있지만 index에서 전달받은 pk를 가지고 접속해보도록 하겠습니다.     하기코드를 입력하겠습니다.        # http://localhost:8000/polls/&lt;숫자&gt;/     path('&lt;int:question_id&gt;/', views.detail, name='detail')  ]     코드설명    ‘path(‘/', views.detail, name='detail')'      ‘http://localhost:8000/polls/question_id ‘     polls/question_id 의 경로일 경우 view.index 함수를 실행합니다.      다시 처음으로 돌아가서 detail.html의 코드를 수정하겠습니다.   &lt;body&gt;     &lt;h1&gt;{ {question.question_text} }&lt;/h1&gt;      &lt;form action=\"\" method=\"post\"&gt;     { % csrf_token % }     { % for choice in question.choice_set.all % }         &lt;input type=\"radio\" id=\"choice{ {forloop.counter} }\"                name=\"choice\"                value=\"choice.id\"         &gt;         &lt;rabel for=\"choice{ {forloop.counter} }\"&gt;             { {choice.choice_text} }         &lt;/rabel&gt;         &lt;br&gt;     { % endfor % }          &lt;input type=\"submit\" value=\"투표\"&gt;     &lt;/form&gt;  &lt;/body&gt;  ]    코드설명    &lt;form action=\"\" method=\"post\"&gt;     post 방식으로 데이터를 받으면 action으로 처리한다는 내용입니다.     submit 버튼을 눌렀을 경우 하기 input에서 name과 value 인자를 다음페이지로 보낼 수 있습니다.       { { question.choice_set.all }}     choice에 해당되는 객체를 모두 받습니다.            &lt;input type=\"radio\" id=\"choice\"                name=\"choice\"                value=\"choice.id\"         &gt;     라디오 버튼을 제작합니다.     id 는 choice1, …     name = choice : 항목을 서로 묶기 위해서 명시합니다. 중복선택을 방지가능합니다.            &lt;rabel for=\"choice{ {forloop.counter} }\"&gt;             { {choice.choice_text} }         &lt;/rabel&gt;     상기 항목에서 명시한 id와 rabel 의 text와 매칭되어 관리 됩니다.     $ python3 manage.py runserver 를 통해 수정된 페이지를 확인해봅시다.           오늘은 poll 프로젝트의 질문지 선택까지 제작해보았습니다.  ","categories": ["Django"],
        "tags": ["Polls","Project","Webapplication"],
        "url": "http://localhost:4000/django/Django-simple-web-application3/",
        "teaser": "https://live.staticflickr.com/3595/3475465970_7044242629_b.jpg"
      },{
        "title": "[Django] Poll 프로젝트 3 (마지막) ",
        "excerpt":"Polls 프로젝트 3  투표시스템 결과확인  저번시간에는 저희가 질문지를 라디오 버튼을 통하여 선택하는 것과 submit버튼을 제작해 보았습니다.   오늘은 제작한 submit버튼을 눌렀을 때 선택한 결과가 반영되어 결과페이지에서 확인하는 기능을 넣어보겠습니다.   방식은 저번 방식과 동일합니다.                  views에 함수추가                  urls에 path 추가                  templates/ .html 생성                  detail.html 과 연결                  templates/ .html 수정후 완료              그렇다면 이제부터 기능을 만들어보겠습니다.   template 폴더에 result.html파일을 생성해줍니다.   polls/views 로 들어가서 하기내용 추가합니다.   def vote(request, choice_id): vote_result = get_object_or_404(Question, pk=choice_id)  selected_vote = vote_result.choice_set.get(pk =                    request.POST['파이썬 라디오버튼에서의 name'])  selected_vote.votes += 1 selected_vote.save() context = {'vote_result':vote_result} return render(request, 'vote.html', context)   코드설명    이전 시간과 중복되는 내용은 제외하고 설명하도록 하겠습니다.      selected_vote = vote_result.choice_set.get(pk =                    request.POST['파이썬 라디오버튼에서의 name'])     라디오 버튼선택한 정보가 name 인자와 value 값의 쌍으로 전달받습니다.     selected_vote.votes += 1 : 선택한 것에 대한 votes 항목을 추가합니다.     selected_vote.save() : 변경된 값을 저장합니다.      polls/ urls.py 파일을 열고 하기 경로를 추가해줍니다.   path ('&lt;int:choice_id&gt;/vote/' , views.vote , name ='vote')     template 폴더에 detail.html파일로 돌아가서 하기처럼 form tag를 수정해줍니다.   &lt;body&gt;      &lt;h1&gt;{ {choice_list.question_text} }&lt;/h1&gt;      &lt;form action=\"{ % url 'polls:vote' choice_list.id % }\" method=\"post\"&gt;     { % csrf_token % }         &lt;ul&gt;             { % for tmp in choice_list.choice_set.all % }             &lt;input type=\"radio\" name=\"choice_button\" id=\"{ { forloop.counter } }\" value=\"{ {tmp.id} }\"&gt;             &lt;label for='{ { forloop.counter } }'&gt;{ {tmp} }&lt;/label&gt;             { % endfor % }             &lt;input type=\"submit\" value=\"제출\"&gt;     &lt;/form&gt;      &lt;/ul&gt; &lt;/body&gt;   코드설명        &lt;form action=\"{ % url 'polls:vote' choice_list.id % }\" method=\"post\"&gt;   post 방식으로 url 의 polls라는 이름에서 name = vote라는 기능을 사용합니다.   인자는 choice_list.id의 객체를 전달합니다.     마지막으로 result.html을 작성하여 마무리 하겠습니다.  &lt;body&gt; &lt;h1&gt;결과도출&lt;/h1&gt;  { %for tmp in my_result.choice_set.all % } &lt;li&gt;{ {tmp} } : { {tmp.votes} } &lt;/li&gt; { %endfor% } &lt;/body&gt;   상기항목을 추가하면 드디어 Poll 프로젝트가 하기 그림처럼 완성됩니다.        이번 시간에는 Poll 프로젝트에 대하여 마무리를 해봤습니다.  ","categories": ["Django"],
        "tags": ["Polls","Project","Webapplication"],
        "url": "http://localhost:4000/django/Django-simple-web-application4/",
        "teaser": "https://live.staticflickr.com/3595/3475465970_7044242629_b.jpg"
      },{
        "title": "API Page",
        "excerpt":"   Django 페이지   [Kakao API] 사용자토큰   [Kakao API] Refresh token   [Kakao API] 나에게 메세지보내기   ","categories": ["API"],
        "tags": [],
        "url": "http://localhost:4000/api/APIPage/",
        "teaser": "http://localhost:4000/assets/image/api_logo.jpeg"
      },{
        "title": "[Kakao API] 사용자토큰 발급받기",
        "excerpt":"Kakao API [User token]   오늘은 Kakao API에 대하여 알아보겠습니다.   저희는 Python 언어를 이용하여 API 를 이용해보도록 하겠습니다.   카카오 API 를 사용하기 위해서는 사용자 토큰을 발급받아야합니다.   하지만 토큰에는 사용시간  제한이 있기 때문에 refresh 토큰을 통해 사용자 토큰을 초기화 해주어야 합니다.   오늘은 사용자 토큰부터 받아보도록 하겠습니다.   토큰별 유효시간   Android, iOS : 12시간 JavaScript: 2 시간 REST API : 6시간   Refresh Token : 2달   이 글은 2020년 8월 20일에 작성되었으며 변동되면 업데이트하도록 하겠습니다.   회원가입 및 로그인   여러분들이 직접 카카오에 있는 사용법을 보고 사용할 수 있도록 설명하겠습니다.   먼저 토큰을 발급받기 위해 카카오 개발자 사이트에 접속하여 회원가입합니다.      회원가입한후 로그인을 진행하고 오른쪽 상단에  내 어플리케이션 을 클릭합니다.      회원가입한 후 로그인을 진행하고 오른쪽 상단에  애플리케이션 추가하기 을 클릭합니다.   App key 발급받기      저희는 REST API 를 이용하여 사용할 예정이므로 REST API 키를 받아 사용하도록 하겠습니다.   활성화 설정      카카오톡 로그인을 하여 서비스를 이용할 예정이므로 제품설정 &gt; 카카오톡 로그인 을 클릭합니다. 활성화 설정을 ON으로 변경하고 Redirect URl 에 원하시는 주소로 입력합니다.   인증 코드 받기   카카오톡 API 사용을 위하여 인증코드를 받아야합니다. 인증 코드 받기  링크로 이동합니다.      GET /oauth/authorize?client_id={REST_API_KEY}&amp;redirect_uri={REDIRECT_URI}&amp;response_type=code HTTP/1.1  Host: kauth.kakao.com   상기 코드를 보고 발급받은 REST_API_KEY 와 REDIRECT_URI 을 추가하여 브라우저 주소창에 입력합니다.   kauth.kakao.com/oauth/authorize?client_id={REST_API_KEY}&amp;redirect_uri={REDIRECT_URI}&amp;response_type=code   입력 후 응답을 기다리면 하기와 같이 URl 이 변경됩니다.   https://localhost.com/?code=JrFxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx   JrFxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 가 저희가 사용할 코드입니다.   사용자 토큰 받기      Response   Key                  Name       Type       Description                       token_type       String       토큰 타입, “bearer”로 고정                 access_token       String       사용자 액세스 토큰 값                 expires_in       Integer       액세스 토큰 만료 시간(초)                 refresh_token       String       사용자 리프레시 토큰 값                 refresh_token_expires_in       Integer       리프레시 토큰 만료 시간(초)                 scope       String       인증된 사용자의 정보 조회 권한 범위 범위가 여러 개일 경우, 공백으로 구분           사용자 토큰을 받기위해 코드를 상기 URL 에서 필수요소들을 request하고 응답값을 .json 형식의 파일로 저장해보겠습니다.   import requests import json # # 초기 키 땡기기 app_key = {REST_API_KEY} # 초기 앱키 rest_key code = \"JrFxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"  url = \"https://kauth.kakao.com/oauth/token\" data = {      \"grant_type\"    : \"authorization_code\",      \"client_id\"     : app_key,      \"redirect_url\"  : \"https://localhost.com\",      \"code\"          : code }  response = requests.post(url, data=data)  tokens = response.json()  print(tokens)  with open(\"kakao_token.json\", 'w') as fp:     json.dump(tokens, fp) # 저장하는 것   response = requests.post(url, data=data) 코드를 통하여 post방식으로 요청하면 응답 값을 받을 수 있습니다.   with open(\"kakao_token.json\", 'w') as fp:     json.dump(tokens, fp)   상기 코드를 통하여 응답값을 kakao_token.json 이름의 .json 형태의 파일로 저장합니다.   이렇게 하여 저희는 사용자토큰을 kakao_token.json 파일에 넣어보았습니다. 사용자 토큰을 바로 사용하는 것도 가능하지만 .json 형태의 파일로 저장하여 구분하였습니다.   오늘은 카카오 API 사용자 토큰을 받아보았습니다.   ","categories": ["API"],
        "tags": ["Kakao","API","Token"],
        "url": "http://localhost:4000/api/kakao_api_usertoken/",
        "teaser": "http://localhost:4000/assets/image/kakao.png"
      },{
        "title": "[Kakao API] Refresh token 발급받기",
        "excerpt":"Kakao API [Refresh token]   오늘은 Refresh token에 대하여 알아보겠습니다.   아직 사용자 토큰을 받지 못하신 분은 [Kakao API] 사용자토큰 을 참고하여 사용자토큰을 먼저 받고 오시면 되겠습니다. Refresh token 토큰은 사용자 토큰을 받는방법과 비슷합니다.   Refresh token 받기   여러분들이 직접 카카오에 있는 사용법을 보고 사용할 수 있도록 설명하겠습니다.   먼저 refresh 토큰을 발급받기 위해 사용자 토큰 갱신하기 항목을 참고합니다.      POST /oauth/token HTTP/1.1 Host: kauth.kakao.com Content-type: application/x-www-form-urlencoded;charset=utf-8   Access token 을 받는 것과 마찬가지로 하기 Request에서 어떤 값을 필수로 입력하여야 하는지 확인합니다.   Request   Parameter                  Name       Type       Description       Required                       grant_type       String       “refresh_token”으로 고정       O                 client_id       String       앱 생성 시 발급 받은 REST API       O                 refresh_token       String       토큰 발급 시 응답으로 받은 refresh_token Access Token을 갱신하기 위해 사용       O                 client_secret       String       토큰 발급 시, 보안을 강화하기 위해 추가 확인하는 코드 [내 애플리케이션] &gt; [보안]에서 설정 가능 ON 상태인 경우 필수 설정해야 함       X           상기의 Request 를 정확히 하면 응답으로 하기 값을 받을수 있습니다. 즉 refresh token을 입력하면 access_token이 변경되는 구조입니다.   Response   Key                  Name       Type       Description                       token_type       String       토큰 타입, “bearer”로 고정                 access_token       String       갱신된 사용자 액세스 토큰 값                 expires_in       Integer       액세스 토큰 만료 시간(초)                 refresh_token       String       갱신된 사용자 리프레시 토큰 값, 기존 리프레시 토큰의 유효기간이 1개월 미만인 경우에만 갱신                 refresh_token_expires_in       Integer       리프레시 토큰 만료 시간(초)           더 밑으로 내려보면 Sample Code를 확인할 수 있습니다.   Sample   Request   curl -v -X POST https://kauth.kakao.com/oauth/token \\  -d 'grant_type=refresh_token' \\  -d 'client_id={REST_API_KEY}' \\  -d 'refresh_token={USER_REFRESH_TOKEN}'   Sample 코드를 바탕으로 Python에서 작업을 해보도록 하겠습니다.   Access token (usertoken) 은 [Kakao API] 사용자토큰 에서 저장한 json 파일을 사용하도록 하겠습니다.   with open(\"kakao_token.json\", 'r') as fp:     tokens = json.load(fp) # json 불러오기  print(tokens)  url = \"https://kauth.kakao.com/oauth/token\" data = {     \"grant_type\"     : \"refresh_token\",     \"client_id\"      : app_key,     \"refresh_token\"  : tokens['refresh_token'] } # response = requests.post(url, data=data) response.status_code response.json() tokens['access_token'] = response.json()['access_token'] tokens['app_key'] = app_key  with open(\"kakao_token.json\", 'w') as fp:     json.dump(tokens, fp) # 저장하는 것   코드설명   tokens['access_token'] = response.json()['access_token']   refresh token을 통해 다시 발급 받은 access_token을 json파일에 저장하여 갱신합니다.   오늘은 카카오 API를 사용하기 위하여 Refresh token 을 발급받아 보았습니다.  ","categories": ["API"],
        "tags": ["Kakao","API","Token"],
        "url": "http://localhost:4000/api/kakao_api_refresh-token/",
        "teaser": "http://localhost:4000/assets/image/kakao.png"
      },{
        "title": "Git Page",
        "excerpt":"   Django 페이지   [Git] 기본명령어   [Github] 원격저장소 활용   [Github] Gitignore   [Github] python 가상환경   ","categories": ["GIT","GITHUB"],
        "tags": [],
        "url": "http://localhost:4000/git/github/GITPage/",
        "teaser": "http://localhost:4000/assets/image/Git.png"
      },{
        "title": "[Git] 기본명령어 및 활용",
        "excerpt":"Git 명령어   오늘은 Git 명령어에 대하여 알아보겠습니다.   기본적인 명령어와 시나리오를 통해 충동상황을 인위적으로 만들어보고 해결해보는 방법으로 알아보겠습니다.   git branch 확인   $ git branch   * master   git branch 생성   $ git branch hellobranch $ git branch  hellobranch \\* master   git 특정 branch 로 이동   $ git checkout hellobranch 'hellobranch' 브랜치로 전환합니다   git branch에서 commit   $ git touch hellobranch.md $ git add . $ git commit -m 'hellobranch' [hellobranch 38888aa] hellobranch  1 file changed, 0 insertions(+), 0 deletions(-)  create mode 100644 hellobranch.md   git master 에서 확인   $ git checkout master 'master' 브랜치로 전환합니다   폴더를 확인하면 branch 에서 생성한 hellobranch.md  파일을 확인할 수 없습니다.   git merge   Branch 에서 작업한 내용을 master에 적용하고 병합하기 위하여   $ git merge hellobranch    git branch 삭제   $ git branch -d {브랜치 이름} $ git branch -d hellobranch hellobranch 브랜치 삭제 (과거 38888aa). $  git branch * master   git branch 생성 및 이동   $ git checkout -b {브랜치 이름} $ touch blog.html $ git add . $ git commit -m 'Complete blog app' $ git log --oneline $ git log --oneline --graph   기타 명령어   restore   작업공간(working directory)의 변경 사항을 버린다.   $ git status On branch master Changes not staged for commit:   (use \"git add &lt;file&gt;...\" to update what will be committed)   # 힌트!   (use \"git restore &lt;file&gt;...\" to discard changes in working directory)         modified:   CLI.txt  no changes added to commit (use \"git add\" and/or \"git commit\") $ git restore CLI.txt           --staged 옵션을 활용하면, staging area를 취소(add 명령어의 반대)       $ git status On branch master Changes to be committed:   (use \"git restore --staged &lt;file&gt;...\" to unstage)         modified:   CLI.txt           $ git restore --staged CLI.txt $ git status On branch master Changes not staged for commit:   (use \"git add &lt;file&gt;...\" to update what will be committed)   (use \"git restore &lt;file&gt;...\" to discard changes in working directory)         modified:   CLI.txt    no changes added to commit (use \"git add\" and/or \"git commit -a\")           커밋 메시지 변경   $ git commit --amend           vim 편집기가 실행된다.            i : 편집 모드로 변경되어서 메시지 변경 가능            esc + :wq : 저장하고 종료            주의!! 공개된 커밋은 절대 변경 금지.       $ git log --oneline 00a6259 (HEAD -&gt; master) TEest f7dc503 First commit    $ git commit --amend [master 4d42f0f] Test  Date: Fri Aug 21 16:17:42 2020 +0900  1 file changed, 1 insertion(+)    $ git log --oneline 4d42f0f (HEAD -&gt; master) Test f7dc503 First commit                           커밋시 특정 파일을 빠트린 경우 아래와 같이 활용할 수 있다.           $ git add omit.html $ git commit --amend                           reset vs revert           revert : 되돌렸다는 커밋이 발생된다.       $ git revert 특정시점 $ git log --oneline 520c668 (HEAD -&gt; master) Revert \"Add 3 files\" 8a97ad4 Add 3 files 4d42f0f Test f7dc503 First commit                reset : 커밋 자체를 지운다. (원격저장소에 공개된 이력의 경우 주의!)       $ git reset 특정시점 $ git log --oneline 4d42f0f (HEAD -&gt; master) Test f7dc503 First commit                           --mixed                   : 기본 설정                      해당 커밋 이후 변경사항을 staging area 내용 보관                                --hard                              해당 커밋 이후 변경사항을 모두 삭제                                --soft                              해당 커밋 이후 변경사항 및 working directory 내용 보관                           Git 시나리오   상황 1. fast-foward      fast-foward는 feature 브랜치 생성된 이후 master 브랜치에 변경 사항이 없는 상황            feature/test branch 생성 및 이동       $ git checkout -b  feature/test                작업 완료 후 commit       $ touch test.html                master 이동       $ git checkout master                master에 병합       $ git merge feature/test                결과 -&gt; fast-foward (단순히 HEAD를 이동)            branch 삭제       $ git branch -d feature/test             상황 2. merge commit      서로 다른 이력(commit)을 병합(merge)하는 과정에서 다른 파일이 수정되어 있는 상황     git이 auto merging을 진행하고, commit이 발생된다.            feature/poll branch 생성 및 이동       git checkout -b feature/poll                작업 완료 후 commit       $ touch poll.html $ git add . $ git commit -m 'complete blog app'                master 이동       $ git checkout master                master에 추가 commit 이 발생시키기!!              다른 파일을 수정 혹은 생성하세요!           $ touch poll.css $ git add . $ git commit -m 'update poll.css'                master에 병합       (master) $git merge feature/poll                결과 -&gt; 자동으로 merge commit 발생                       vim 편집기 화면이 나타납니다.                        자동으로 작성된 커밋 메시지를 확인하고, esc를 누른 후 :wq를 입력하여 저장 및 종료를 합니다.                      w : write           q : quit                                커밋이  확인 해봅시다.                        그래프 확인하기       $git log --oneline --graph \\*  43a7747 (**HEAD -&gt;** **master**) Merge branch 'feature/poll' |\\   | * b2dcf72 (**feature/poll**) complete blog app \\* | bacdf1a update poll.css |/   \\* d9ccd8f Complete blog app \\* 38888aa hellobranch \\* 5e8b5fb init                branch 삭제         $ git branch -d feature/poll     상황 3. merge commit 충돌      서로 다른 이력(commit)을 병합(merge)하는 과정에서 동일 파일이 수정되어 있는 상황     git이 auto merging을 하지 못하고, 해당 파일의 위치에 라벨링을 해준다.     원하는 형태의 코드로 직접 수정을 하고 merge commit을 발생 시켜야 한다.            feature/board branch 생성 및 이동       $ git checkout -b feature/board                작업 완료 후 commit                       Readme 파일 수정 후 아래 명령어           $ touch board $ git add . $ git commit -m 'edit readme and board'                                master 이동       $ git checkout master                master에 추가 commit 이 발생시키기!!                       동일 파일을 수정 혹은 생성하세요!                        readme .md 수정!           $ git add . $ git commit -m 'edit readme and board'                                master에 병합       $ git merge feature/board 자동 병합: readme.md     충돌 (내용): readme.md에 병합 충돌     자동 병합이 실패했습니다. 충돌을 바로잡고 결과물을 커밋하십시오.                결과 -&gt; merge conflict발생       admin@adminui-MacBookPro Django % git status 현재 브랜치 master 병합하지 않은 경로가 있습니다.   (충돌을 바로잡고 \"git commit\"을 실행하십시오)   (병합을 중단하려면 \"git merge --abort\"를 사용하십시오)     커밋할 변경 사항: \t새 파일:       board.html     병합하지 않은 경로:   (해결했다고 표시하려면 \"git add &lt;파일&gt;...\"을 사용하십시오) \t양쪽에서 수정:  readme.md                충돌 확인 및 해결       중복되었을때 둘다 표시도 가능하고 하나만 선택하는 것이 가능 (vs, pycharm에서 선택가능)            merge commit 진행       $ git commit                           vim 편집기 화면이 나타납니다.                        자동으로 작성된 커밋 메시지를 확인하고, esc를 누른 후 :wq를 입력하여 저장 및 종료를 합니다.                      w : write           q : quit                                커밋이  확인 해봅시다.                        그래프 확인하기       $ git add . $ git commit -m 'resolveconflict' [master 4a75bda] resolveconflict     $ git log --oneline --graph            *   4a75bda (HEAD -&gt; master) resolveconflict |\\   | * d7040c2 (feature/board) edit readme and board * | eb7b350 edit_readme_master |/   *   43a7747 Merge branch 'feature/poll' |\\   | * b2dcf72 complete blog app * | bacdf1a update poll.css |/   * d9ccd8f Complete blog app * 38888aa hellobranch * 5e8b5fb init                branch 삭제       $ git branch -d feature/board          ","categories": ["Git"],
        "tags": ["Git","Github"],
        "url": "http://localhost:4000/git/Git/",
        "teaser": "http://localhost:4000/assets/image/Git.png"
      },{
        "title": "[Git Hub] 원격저장소 활용",
        "excerpt":"Git 원격 저장소 활용   Git 원격 저장소 기능을 제공 해주는 서비스는 gitlab , bitbucket, github 등이 있다.   0. 원격 저장소 설정   $ git remote add origin {url} $ git remote add origin https://github.com/edutak/TIL.git           git, 원격저장소를 추가(add)하고 origin 이라는 이름으로 url 으로 설정            설정된 저장소를 확인하기 위해서는 아래의 명령어를 사용한다.       $ git remote -v origin  https://github.com/edutak/TIL.git (fetch) origin  https://github.com/edutak/TIL.git (push)           1. 원격 저장소 복제   $ git clone {url}      해당 명령어를 입력한 위치에 원격저장소 이름으로 폴더가 생기며, 저장소가 복제 된다.   2. push   $ git push origin master Enumerating objects: 13, done. Counting objects: 100% (13/13), done. Delta compression using up to 8 threads Compressing objects: 100% (10/10), done. Writing objects: 100% (13/13), 40.38 KiB | 13.46 MiB/s, done. Total 13 (delta 1), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (1/1), done. To https://github.com/edutak/TIL.git  * [new branch]      master -&gt; master Branch 'master' set up to track remote branch 'master' from 'origin'.      원격저장소(origin) 의 mater 브랜치로 기록된 커밋(버전)이 업데이트된다.   3. pull   $ git pull origin master      원격저장소(origin)의 master 브랜치의 기록된 커밋(버전)이 현재 로컬 저장소로 받아온다.   Branch를 생성할 경우 commit 과 push를 모두 branch에서 실행해야합니다.  ","categories": ["Git"],
        "tags": ["Git","Github"],
        "url": "http://localhost:4000/git/Github/",
        "teaser": "http://localhost:4000/assets/image/Git.png"
      },{
        "title": "[Git Hub] 가상환경",
        "excerpt":"gitignore      특정한 파일 및 폴더를 git으로 추적하지 않도록 설정    사용법      git 저장소 내부에 .gitignore 파일을 생성한다.       git에서 제외시키고 싶은 형식을 지정한다.    a.html   \t\t\t \t\t # a.html 특정파일 secret/   \t\t\t\t\t# secret 특정 폴더 !secret/test.xlsx   #secret  폴더내의 test.xlsx는 gitignore에서 뺀다 &gt; git으로 관리하겠다. *.xlsx \t\t\t\t\t\t\t# 확장자가 .xlsx인 모든 파일   예시      일반적으로 특정언어, 환경변수, 특정 개발 환경(IDE, 텍스트에디터), 운영체제 관련된 파일들   ","categories": ["Git"],
        "tags": ["Git","Github"],
        "url": "http://localhost:4000/git/gitignore/",
        "teaser": "http://localhost:4000/assets/image/Git.png"
      },{
        "title": "[Git Hub] 가상환경",
        "excerpt":"파이썬 가상 환경   사용법           가상환경 생성                       venv 라는 이름의 가상환경을 생성           python3 -m venv {가상환경이름} python3 -m venv venv                                 가상환경을 생성하면 해당 디렉토리에 venv 폴터가 생성된다.                        가상환경 실행       $ source venv/Scripts/activate\t\t\t# git bash용 $ source venv/Scripts/activate.bat\t# cmd용 $ source venv/Scripts/activate.psl\t# 파워쉘 용 (venv) $                가상환경을 실행시킨 상태에서 파이썬 패키지(pip)를 설치하게 되면 venv 폴더의 Lib폴더에 설치를 하게 된다.              해당프로젝트를 위한 패키지들을 따로 관리할 수 있다.           pip   # requirements.txt에 설치된 패키지 기록 $ pip freeze &gt; requirements.txt # requirements.txt에 설치된 패키지들을 설치 $ pip install -r requirements.txt   ","categories": ["Git"],
        "tags": ["Git","Github","Python"],
        "url": "http://localhost:4000/git/virtualenvironmnet/",
        "teaser": "http://localhost:4000/assets/image/Git.png"
      },{
        "title": "[Kakao API] 나에게 메세지보내기",
        "excerpt":"Kakao API [Self message]   오늘은 카카오톡 나에게 메세지보내기에 대하여 알아보겠습니다.   토큰을 받지 못하신 분은 [Kakao API] 사용자토큰 , [Kakao API] Refresh token 을 참고하셔서 토큰을 선행해서 받아주세요.   카카오톡 나에게 메세지 보내기   이번에도 여러분들이 직접 카카오에 있는 사용법을 보고 사용할 수 있도록 설명하겠습니다. 메세지를 보내기 위해 나에게 보내기 항목을 참고합니다.      Request   POST /v2/api/talk/memo/default/send HTTP/1.1 Host: kapi.kakao.com Authorization: Bearer {USER_ACCESS_TOKEN}   Parameter                  Name       Type       Description       Required                       template_object       JSON Object       메시지 구성 요소를 담은 객체(Object) 피드, 리스트, 위치, 커머스, 텍스트 중 하나       O           Response   Key                  Name       Type       Description                       result_code       Integer       전송 성공 시 0           Sample   curl -v -X POST \"https://kapi.kakao.com/v2/api/talk/memo/default/send\" \\     -H \"Authorization: Bearer {USER_ACCESS_TOKEN}\" \\     -d 'template_object={         \"object_type\": \"text\",         \"text\": \"텍스트 영역입니다. 최대 200자 표시 가능합니다.\",         \"link\": {             \"web_url\": \"https://developers.kakao.com\",             \"mobile_web_url\": \"https://developers.kakao.com\"         },         \"button_title\": \"바로 확인\"     }'   오늘은 텍스트를 보내보도록 하겠습니다. parameter에 텍스트를 클릭하여 하여도 가능하지만 아주쉽게 샘플코드를 복사하여 코드를 작성해보겠습니다.   with open(\"static/my_squat/kakao_token.json\", 'r') as fp:     tokens = json.load(fp)   url = \"https://kapi.kakao.com/v2/api/talk/memo/default/send\" headers = {\"Authorization\": \"Bearer \" + tokens['access_token']}  template_object = { \t\t'object_type': 'text', \t\t'text': '텍스트 영역입니다. 최대 200자 표시 가능합니다.', \t\t'link': { \t\t\t\t'web_url': 'https://daum.net',     },     'button_title': '바로 확인' }  data = {'template_object': json.dumps(template_object)} # return request('post', url, data=data, json=json, **kwargs) response = requests.post(url, headers=headers, data=data) print(response.status_code)   샘플을 보고 작성을 하고 동일하게 작성을 해보았습니다.   코드설명   data = {'template_object': json.dumps(template_object)}   Data 는 template_object이름으로 json 파일 형식으로 url을 통해 요청을 보냅니다.   요청이 성공적으로 전송이 되면  print(response.status_code) 코드에서 200이라는 메세지와 함께 카카오톡 메세지를 확인할 수 있습니다.      오늘은 카카오톡 나에게 보내기를 해보았습니다. 궁금하시거나 안되는 기능이 있으면 언제든 댓글을 남겨주세요!  ","categories": ["API"],
        "tags": ["Kakao","API","Self message"],
        "url": "http://localhost:4000/api/kakao_api_selfmessage/",
        "teaser": "http://localhost:4000/assets/image/kakao.png"
      },{
        "title": "[Algorithm] Greedy Algorithm",
        "excerpt":"Greedy Algorithm   오늘은 Greedy Algorithm에 대하여 알아보겠습니다.   Greedy Algorithm은 말 그대로 탐욕 알고리즘입니다. 탐욕 알고리즘은 최적해를 구하는데 사용되는 근사적인 방법으로 최적이라고 생각되는 것을 선택해 나가는 방식으로 정답에 도달하는 방법입니다. 전체적인 상황을 고려하지 않고 현재상황에서 가장 최적의 것을 선택하는 방법입니다.   모든문제를 순차적으로 풀면 정확한 정답을 얻을 수 있겠으나 시간적으로나 용량적으로 효율적이지 못한경우에는 알고리즘의 다양한 방법을 통하여 좀더 효율적이게 문제를 해결할 수 있습니다.   그럼 바로 Greedy Algorithm에 대하여  몇가지 문제를 통하여 알아보도록 하겠습니다.   거스름돈 문제   물건값은 n으로 주어집니다. 거스름돈의 동전의 종류는 4종류 이며 500원 100원 50원 10원이며 거스름돈의 동전 개수를 최대한 적게 하려고 할때의 동전개수를 출력하는 프로그램을 작성해보세요.   n = 800 coin = [500, 100, 50, 10] count = 0 for i in coin:   #큰 동전부터 먼저 거슬러줍니다.   count += n//i   # 동전을 거슬러주고 남은돈이 다음동전에서 연산되도록 처리합니다.   n = n%i print(count)\t#4   화폐의 종류가 K 라고 할때 소스코드의 시간복잡도는 O(K) 입니다.   연산 문제   어떠한 수 N이 1이 될 때까지 다음 두가지 연산 중 한가지만 수행하려고합니다.           N 에서 1을 뺍니다.            N을 K로 나눕니다. (단 N이 K로 나눠질 경우에만 사용 가능)       1이 될때까지의 연산의 횟수를 출력하는 프로그램을 작성해보세요.   예) N이 17 이고 K 가 4 이면 정답은 3입니다.   N = 17 K = 4 count = 0 while N &gt; 1:   if N % K == 0:     N = N/K   else:     N = N-1   count += 1   print (count) #3   좀더 효율적으로 풀어보도록 하겠습니다.   N = 17 K = 4 count = 0 while True:   # N을 K로 나눈 몫을 K로 다시곱해서 -1을 해야하는 부분을 한번에 추출함   target = (N//K)*K   count += n - target      if N &lt; K:     break   N //= K   count += 1  # 마지막으로 남은 수에 대하여 카운트를 해줌 count += (N-1) print(count)   곱하기 혹은 더하기   각 자리가 숫자 (0~9)로만 이루어진 문자열 S가 주어졌을때 왼쪽부터 오른쪽까지 하나씩 모든숫자를 확인하면 +혹은 X연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하세요.   예) 02984 = (0+2)X9X8X4 = 576  S = input()  sum_num = int(S[0])  for i in range(1, len(S)):   if int(S[i]) &lt;=1:     sum_num += int(S[i])   else:     sum_num *= int(S[i])      print(sum_num)   좀더 효율적으로 풀어보도록 하겠습니다.   S = input() sum_num = 0 for i in range(0, len(S)):     sum_num = max(sum_num + int(S[i]), sum_num * int(S[i])) print(sum_num)   오늘은  Greedy Algorithm에 대하여 알아보았습니다.   ","categories": ["Algorithm"],
        "tags": ["Greedy"],
        "url": "http://localhost:4000/algorithm/Greedy-Algorithm/",
        "teaser": "http://localhost:4000/assets/image/Algorithm.png"
      },{
        "title": "[Algorithm] Implementation",
        "excerpt":"Implementation   오늘은 Implementation에 대하여 알아보겠습니다.   시뮬레이션과 완전탐색   Greedy Algorithm은 말 그대로 탐욕 알고리즘입니다. 탐욕 알고리즘은 최적해를 구하는데 사용되는 근사적인 방법으로 최적이라고 생각되는 것을 선택해 나가는 방식으로 정답에 도달하는 방법입니다. 전체적인 상황을 고려하지 않고 현재상황에서 가장 최적의 것을 선택하는 방법입니다.   모든문제를 순차적으로 풀면 정확한 정답을 얻을 수 있겠으나 시간적으로나 용량적으로 효율적이지 못한경우에는 알고리즘의 다양한 방법을 통하여 좀더 효율적이게 문제를 해결할 수 있습니다.   그럼 바로 Greedy Algorithm에 대하여  몇가지 문제를 통하여 알아보도록 하겠습니다.   거스름돈 문제   물건값은 n으로 주어집니다. 거스름돈의 동전의 종류는 4종류 이며 500원 100원 50원 10원이며 거스름돈의 동전 개수를 최대한 적게 하려고 할때의 동전개수를 출력하는 프로그램을 작성해보세요.   n = 800 coin = [500, 100, 50, 10] count = 0 for i in coin:   #큰 동전부터 먼저 거슬러줍니다.   count += n//i   # 동전을 거슬러주고 남은돈이 다음동전에서 연산되도록 처리합니다.   n = n%i print(count)\t#4   화폐의 종류가 K 라고 할때 소스코드의 시간복잡도는 O(K) 입니다.   연산 문제   어떠한 수 N이 1이 될 때까지 다음 두가지 연산 중 한가지만 수행하려고합니다.           N 에서 1을 뺍니다.            N을 K로 나눕니다. (단 N이 K로 나눠질 경우에만 사용 가능)       1이 될때까지의 연산의 횟수를 출력하는 프로그램을 작성해보세요.   예) N이 17 이고 K 가 4 이면 정답은 3입니다.   N = 17 K = 4 count = 0 while N &gt; 1:   if N % K == 0:     N = N/K   else:     N = N-1   count += 1   print (count) #3   좀더 효율적으로 풀어보도록 하겠습니다.   N = 17 K = 4 count = 0 while True:   # N을 K로 나눈 몫을 K로 다시곱해서 -1을 해야하는 부분을 한번에 추출함   target = (N//K)*K   count += n - target      if N &lt; K:     break   N //= K   count += 1  # 마지막으로 남은 수에 대하여 카운트를 해줌 count += (N-1) print(count)   곱하기 혹은 더하기   각 자리가 숫자 (0~9)로만 이루어진 문자열 S가 주어졌을때 왼쪽부터 오른쪽까지 하나씩 모든숫자를 확인하면 +혹은 X연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하세요.   예) 02984 = (0+2)X9X8X4 = 576  S = input()  sum_num = int(S[0])  for i in range(1, len(S)):   if int(S[i]) &lt;=1:     sum_num += int(S[i])   else:     sum_num *= int(S[i])      print(sum_num)   좀더 효율적으로 풀어보도록 하겠습니다.   S = input() sum_num = 0 for i in range(0, len(S)):     sum_num = max(sum_num + int(S[i]), sum_num * int(S[i])) print(sum_num)   오늘은  Greedy Algorithm에 대하여 알아보았습니다.   ","categories": ["Algorithm"],
        "tags": ["Implementation"],
        "url": "http://localhost:4000/algorithm/Implementation/",
        "teaser": "http://localhost:4000/assets/image/Algorithm.png"
      },{
        "title": "[Python] Anaconda & Jupyter Notebook 설치 및 가상환경 설정",
        "excerpt":"ANACONDA   오늘은 ANACONDA 에 대하여 알아보도록 하겠습니다.   ANACONDA 를 사용하는 이유는 다음과 같습니다.      라이브러리를 별도로 설치하지 않아도 된다.   가상환경을 사용할 수 있다.   ANACONDA 설치   그렇다면 우선 설치부터 해보도록 하겠습니다.      아나콘다 다운로드 링크 에 접속하여 해당되는 버전을 다운로드 하도록 하겠습니다.            저는 MAC 환경에서 사용하므로 MAC 버전용으로 다운로드 하도록 하겠습니다.            다운로드가 되었다면 별다른 설정없이 설치를 해주시면 됩니다.            다만 윈도우 사용자분들께서는 경로설정(path)를 유의하시어 설치하시면 되겠습니다.            가상환경 생성   설치가 완료되었다면 가상환경을 만들어 보도록 하겠습니다.   Mac사용자분들을 터미널을 열어주시고 윈도우 사용자분들께서는 Anaconda prompt를 실행시켜주시면 되겠습니다.   실행하시면 이전과는 다르게 (base) 라는 부분이 생성이 되어있는 것을 확인하실 수가 있습니다.         가상환경이름은 “data_env” 로 지정하고 파이썬 버전은 3.7 버전으로 설치하겠습니다.            $ conda create -n data_env python=3.7 openssl                  설치가 다 되었다면 제대로 설치가 되어있는지 확인하겠습니다.            $ conda info -—envs                  만들어진 가상환경으로 접속합니다.            $ conda activate data_env                  가상환경을 탈출하기 위해서는 하기 명령어를 입력합니다.            $ conda deactivate                  Jupyter notebook  가상환경 설치가 완료되면 개발도구인 IDE를 설치를 해야합니다. 저는 Jupiter notebook이라는 web기반의 개발툴을 이용하겠습니다.   현재 data_env 가상환경에서 하기명령어를 이용하여 nb_conda를 설치하도록 하겠습니다.  $ conda install nb_conda   경로설정   Jupyter notebook 이 사용할 기본 디렉토리 (working directory)를 지정 하도록 하겠습니다. 이 작업을 하기위해 환경 설정 파일을 하나 생성해서 기본 디렉토리를 지정해서 사용해보도록 하겠습니다.   $ jupyter notebook --generate-config   명령어를 입력하면 .jupyter 라는 숨김폴더가 생성되고 그 안에 jupter_notebook_config.py 파일이 생성됩니다.   그 중 jupter_notebook_config.py 파일에서 하기항목에 경로이름을 입력하여 기본 디렉토리 (working directory)를 설정하겠습니다.      ##The directory to use for notebooks and kernels. #c.NotebookApp.notebook_dir = ‘경로이름’    Jupyter Notebook 실행   상기 설정이 전부 완료되었다면 Jupyternotebook을 실행해보도록 하겠습니다.   $ jupyter notebook   명령어를 입력하면 바로 Jupyter Notebook이 실행되는 것을 확인할 수 있습니다.   Jupyter Notebook 사용   Jupyternotebook 에서  ` cell`에 대하여 설명하도록 하겠습니다.    cell을 선택하면 초록색으로 표시되며 선택하지 않으면 파란색으로 표시됩니다.         셀 추가   B는 아래 쪽에 셀 추가 A 키는 cell을 위쪽에 추가 하는 명령어 입니다. 지우려면 D 키를 두번 눌러서 지울수 있습니다.      셀 추가   셀은 서로 데이터나 정보가 공유됩니다. 앞서 셀에서 ‘a’를 정의하였다면 다른 셀에서 사용할 수 있습니다.      오늘은 Anaconda와 Jupyternotebook에 대하여 알아보았습니다.  ","categories": ["Python"],
        "tags": ["ANACONDA"],
        "url": "http://localhost:4000/python/Anaconda/",
        "teaser": "http://localhost:4000/assets/image/image-20200904205041347.png"
      },{
        "title": "[Python] Numpy-1",
        "excerpt":"Numpy -1   오늘은  Numpy 에 대하여 알아보도록 하겠습니다. Numpy 란 Numerical Python 의 약자입니다. 대규모 다차원 배열과 행렬 연산에 필요한 다양한 함수를 제공합니다.   Numpy module   Numpy의 자료구조를 배워보도록 하겠습니다. ndarray 배열에 대하여 배워보도록 하겠습니다.   Numpy는 ndarray 라고 불리는 n-차원의 배열을 제공합니다.   Numpy &amp; Pandas   pandas module은  data handling, machine learing 에 학습할 데이터를 준비하는 module입니다.   Numpy는 vector와 matrix 연산에 특화되어 있습니다. 또한 Pandas와 Matplotlib의 기반이 되는 module 이며 machine learning, deep learning 에서 많이 사용됩니다.   Numpy 설치   numpy를 실행해보아요 !! 하지만 깔려있지 않기 때문에 Numpy 모듈을 설치하고 진행해야 합니다.   설치하는 방법에는 두가지 방법이 있습니다.           Pip3 install numpy            conda install numpy       주의 할점은 꼭 설정된 가상환경을 활성화 시킨 이후에 명령어를 작성하셔야 합니다.   Numpy VS List   ndarray의 특징 : python의 list와 상당히 유사  (표로 작성해봅시다 !!)      python의 list 는 다른 데이터 타입을 같이 list안에 저장이 가능합니다.   Numpy의 ndarray는 모두 같은 데이터 타입을 사용해야 해요.   Python의 list 보다 메모리 효율이나 실행속도면에서 우위가 있습니다.   하기 예제를 보면서 차이점을 찾아보도록 하겠습니다.   #### List  a = [1,2,3,4,5] # python의 list print(a) # [1,2,3,4,5] &gt; list literal print(type(a))# &lt;class 'list'&gt;  #### Numpy  import numpy as np arr = np.array([1,2,3,4,5]) arr = np.array(파이썬의 list) print(arr) #[1 2 3 4 5] 콤마로 구분되지 않고 띄어쓰기로 구분됩니다. print(type(arr)) # &lt;class 'numpy.ndarray'&gt; print(arr.dtype) # int64(int : 정수, 64:64bit) print(arr[0]) # 1 &gt; python 에서는 'int' print(type(arr[0])) # &lt;class 'numpy.int64'&gt; class type이 다름  arr = np.array([100,3.14,True,'Hello']) # Numpy 안에는 같은 데이터 타입이 들어가야합니다. print(arr) # ['100' '3.14' 'True' 'Hello'] 가능한 데이터 타입을 일치시켜서 출력   다차원 ndarray를 만들어 보아요! Python의 list는 중첩리스트만 존재해요!   a = [[1,2,3],      [4,5,6]] # python 에서는 2차원 리스트라고 부르지는 않아요 !   arr = np.array(a) print(arr) print(arr[1] [1])   a = [[1,2,3],      [4,5,6]] # python 에서는 2차원 리스트라고 부르지는 않아요 ! arr = np.array(a, dtype =np.float64)# 지정하지 numpy가 자동으로 판단해서 지정 print(arr)   [[1. 2. 3.]  [4. 5. 6.]]   ndarray의 차원 관련 속성을 알아보아요!!    a = [1, 2, 3, 4] arr = np.array(a, dtype=np.float64) print(arr) #[1. 2. 3. 4.] print(arr.ndim) #ndim &gt; 차원의 개수 : 1 print(arr.shape) # 차원의 개수와 각차원의 요소를 tuple로 표현  \t\t\t\t\t\t\t\t # (4,)    a = [[1, 2, 3],      [4, 5, 6],      [7, 8 ,9],      [10, 11, 12]] arr = np.array(a, dtype=np.float64) print(arr) print(arr.ndim) #ndim &gt; 차원의 개수 : 2 print(arr.shape) # 차원의 개수와 각차원의 요소를 tuple로 표현                  # (4, 3)    a = [[[1, 2, 3],      [4, 5, 6]],      [[1, 2, 3],      [4, 5, 6]]] arr = np.array(a, dtype=np.float64) print(arr) ''' [[[1. 2. 3.]   [4. 5. 6.]]   [[1. 2. 3.]   [4. 5. 6.]]]  ''' print(arr.ndim) #ndim &gt; 차원의 개수 : 3 print(arr.shape) # 차원의 개수와 각차원의 요소를 tuple로 표현                  # (2, 2, 3)   numpy array(ndarray)의 크기를 알아보아요!   a = [[1,2,3], [4,5,6], [7,8,9], [10,11,12]] # 4 X 3 arr = np.array(a, dtype = np.float64) print(arr) print(arr.size) # 12 // 현재 np가 가지고 있는 모든요소의 개수 print(len(arr)) #4 // 첫번째 차원의 요소 개수를 리턴 // 행의 개수를 리턴합니다. print(arr.shape) # (4,3)  arr.shape = (2, 6) # shape을 변경이 가능 print(arr) ''' [[ 1.  2.  3.  4.  5.  6.]  [ 7.  8.  9. 10. 11. 12.]] '''  arr.shape = (3, 2, 2) print(arr) ''' [[[ 1.  2.]   [ 3.  4.]]   [[ 5.  6.]   [ 7.  8.]]   [[ 9. 10.]   [11. 12.]]] '''  arr.shape = (3, 2, 3) # size는 맞춰서 shape이 변경가능 print(arr) ''' --------------------------------------------------------------------------- ValueError                                Traceback (most recent call last) &lt;ipython-input-41-11d631f7d9d2&gt; in &lt;module&gt;      14 print(arr)      15  ---&gt; 16 arr.shape = (3, 2, 3)      17 print(arr)  ValueError: cannot reshape array of size 12 into shape (3,2,3) '''   ndarray의 데이터 타입을 변경하려면??   ndarray를 생성할 때 dtype을 지정해서 만들지만 변경이 가능합니다. 바로 astype 을 통해서 변경이 가능합니다.   하기 예제를 통해서 알아보도록 하겠습니다.   import numpy as np arr = np.array([1.5, 2.3, 8.3, 9.8, 7.7], dtype = np.float64) print(arr) # [1.5 2.3 8.3 9.8 7.7]   result = arr.astype(np.int32) print(result) # [1 2 8 9 7] // 정수형태로 변환되며 버림처리됩니다. print(result.dtype) #int32   ndarray를 만드는 형태는 여러가지입니다.   import numpy as np arr = np.zeros((3,4)) #0으로 채워서 ndarray를 만들수 있어요 print(arr) ''' [[0. 0. 0. 0.]  [0. 0. 0. 0.]  [0. 0. 0. 0.]] '''  arr = np.ones((3,4)) print(arr) ''' [[1. 1. 1. 1.]  [1. 1. 1. 1.]  [1. 1. 1. 1.]] '''  arr = np.full((3,5), 7, dtype=np.float64) print(arr) ''' [[7. 7. 7. 7. 7.]  [7. 7. 7. 7. 7.]  [7. 7. 7. 7. 7.]] '''   arr = np.empty((3,3)) # 3 X 3 ndarray 를 생성하는데 ..초기값을 주지않아요                       # 내가 원하는 shape의 공간만 설정 // 초기화 하지않아 만드는 속도가 빨라서 사용 print(arr) ''' [[ 6.17779239e-31 -1.23555848e-30  3.08889620e-31]  [-1.23555848e-30  2.68733969e-30 -8.34001973e-31]  [ 3.08889620e-31 -8.34001973e-31  4.78778910e-31]] '''    _like   arr = np.array([(1,2,3), (4,5,6)]) print(arr) ''' [[1 2 3]  [4 5 6]] '''  result = np.zeros_like(arr) # 위에서 만든 2 X 3 행렬에 대하여 동일한 size의 행렬을 만들어요 print(result) ''' [[0 0 0]  [0 0 0]] '''   ndarray를 만드는 다른 방법 - arange   python의 range와 상당히 유사합니다.   주어진 범위 내에서 지정한 간격으로 연속적인 원소를 가진 ndarray를 생성합니다.   하기 예제를 보면서 확인해보록 하겠습니다.   a = range(1,10,1) print(a) # range(1, 10)  arr = np.arange(1,10,1) print(arr) # [1 2 3 4 5 6 7 8 9]   ndarray를 만드는 다른 방법 - linspace   linspace 기능을 확인하기 위해서 그래프로 데이터를 그려보도록 하겠습니다. matplotlib module, ` seaborn` 라는 모듈을 이용해서 그래프를 그릴 수 있습니다.   이번시간에는 matplotlib을 사용해보도록 하겠습니다. 이것도 마찬가지로 pip 혹은 conda를 이용해서 설치하도록 하겠습니다.   conda install matplotlib 의 설치명령어로 터미널을 통해서 설치하도록 하겠습니다.   설치 이후 간단한 예제를 통하여 linspace를 자세하게 알아보도록 하겠습니다.   import numpy as np import matplotlib.pyplot as plt ''' np.linspace(start, stop, num)  start 부터 시작해서 stop의 범위에서 num개의 숫자를  균일한 간격으로 데이터를 생성해서 ndarray를 만드는 함수 '''  arr = np.linspace(0,10,11) print(arr) #[ 0.  1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]   arr = np.linspace(0,10,13) print(arr) ''' [ 0.          0.83333333  1.66666667  2.5         3.33333333  4.16666667   5.          5.83333333  6.66666667  7.5         8.33333333  9.16666667  10.        ] '''   arr = np.linspace(1,121,31) #원소간의 간격은 (stop - start) / (num -1) print(arr)  ''' [  1.   5.   9.  13.  17.  21.  25.  29.  33.  37.  41.  45.  49.  53.   57.  61.  65.  69.  73.  77.  81.  85.  89.  93.  97. 101. 105. 109.  113. 117. 121.] '''  plt.plot(arr, \"*\") # 각각의 점들을 *로 표시하여 나타냅니다. plt.show()      ndarray를 생성할 때 랜덤값 기반으로 생성할 수 있어요   총 다섯가지 방법으로 ndarray를 생성할 수 있어요!!           np.random.normal() : 정규분포 확률 밀도함수에서 실수 표본을 추출해서 ndarray 생성 (평균, 표준편차)       import numpy as np import matplotlib.pyplot as plt     mean = 50 std = 2 arr = np.random.normal(mean, std, (10000,)) # 10000개의 데이터 추출 print(arr) ''' [47.48597904 51.09675807 48.58847913 ... 48.31064207 47.61720963  50.06721122] '''     # 히스토그램 plt.hist(arr, bins = 100) # 히스토그램의 x축의 간격을 100개로 쪼개서 만듦 plt.show()                      np.random.rand() : 실수를 추출하는데 (0,1) 범위에서 추출하고 균등분포로 추출       arr = np.random.rand(100000) print(arr) plt.hist(arr, bins=100) plt.show()                       np.random.randn(d0,d1,d2, …) : 실수추출 , 표준정규분포에서 난수를 추출 평균0, 표준편차 1       arr = np.random.rand(100000) print(arr) plt.hist(arr, bins=100) plt.show                      np.random.randint(low,high, shape) : 균등분포 확률밀도함수에서 난수를 추출하는데 정수값을 난수로 추출       arr = np.random.randint(-100,100,(100000, )) print(arr) plt.hist(arr, bins =100) plt.show()                       np.random.random(shape) : [0,1) 균등분포에서 실수 난수를 추출!       arr = np.random.random((100000, )) print(arr) plt.hist(arr, bins=100) plt.show()                  Numpy 가 제공하는 랜덤 관련 함수           난수의 재현       하기코드로 작성하면 매번 실행시 마다 새로운 random 값이 도출됩니다.       arr = np.random.randint(0, 100, (10,)) print(arr) # [60 72  4  8 98 88 69 54 83 30]           하지만 랜덤 값도 실제로는 특정 알고리즘의 결과물이기에 초기에 시작값을 설정해주면 항상 같은 랜덤값이 도출됩니다.       np.random.seed(10) # 한번뽑은 랜덤값을 같은값으로 도출되도록 설정 arr = np.random.randint(0, 100, (10,)) print(arr)  ''' [ 9 15 64 28 89 93 29  8 73  0] [ 9 15 64 28 89 93 29  8 73  0] [ 9 15 64 28 89 93 29  8 73  0] [ 9 15 64 28 89 93 29  8 73  0] '''                ndarray의 순서를 램덤하게 바꿀려면 어떻게 해야하나요?       arr = np.arange(10) print(arr) # [0 1 2 3 4 5 6 7 8 9]     np.random.shuffle(arr) # ndarray 자체가 변형되요! print(arr) # [1 5 2 9 7 0 3 4 6 8]                ndarray 안에서 일부 부작위로 선택하는 기능. sampling기능을 수행하려면       np.random.choice(arr, size, replace, p)       arr : numpy array가 나오거나 혹은 정수가 나올 수 있어요! 만약 정수면       정수만 쓰면 : arange(정수) 가 실행 size : 정수값. 샘플의 숫자 replace : Boolean (True, False)           True : 한번 선택한 데이터를 다시 샘플링 할 수 있어요! p(확률) : ndarray. 각 데이터가 샘플링 될 확률을 가지고 있는 ndarray       arr = np.random.choice(5,3,replace = True ) print(arr) #[1 1 3] 값 중복 가능     arr = np.random.choice(5,3,replace = False ) print(arr) #[0 4 1] 값 중복 불가능     arr = np.random.choice(5,10,replace = True,p = [0.2, 0, 0.3, 0.4, 0.1]  ) print(arr) #[0 2 0 3 2 0 3 0 2 3] 1은 0%이기 때문에 나올 수가 없음           ndarray는 shape을 가지고 있어요!   # shape 속성의 값을 바꾸어서 ndarray의 형태를 변경하는 것은 그다지 좋지 않아요! # reshape() 항수를 이용해서 처리합니다.  import numpy as np arr = np.arange(0,12,1) arr1 = arr.reshape(4,3) # 새로운 ndarray를 만드는게 아니라 view를 생성. print (arr) print (arr1)  ''' [ 0  1  2  3  4  5  6  7  8  9 10 11]  [[ 0  1  2]  [ 3  4  5]  [ 6  7  8]  [ 9 10 11]] '''  arr[0] =100 print(arr)  print(arr1) #데이터 공유  ''' [100   1   2   3   4   5   6   7   8   9  10  11]  [[100   1   2]  [  3   4   5]  [  6   7   8]  [  9  10  11]] '''  arr = np.arange(0,12,1) arr1 = arr.reshape(-1,4) print(arr1)  ''' [[ 0  1  2  3]  [ 4  5  6  7]  [ 8  9 10 11]] '''  arr = np.arange(0,12,1) arr1 = arr.reshape(2,3,-1) print(arr1) ''' [[[ 0  1]   [ 2  3]   [ 4  5]]   [[ 6  7]   [ 8  9]   [10 11]]] '''   arr = np.arange(0,12,1) arr1 = arr.reshape(2,6).copy() # 데이터 공유하지않고 새로운 ndarray를 제작하려면 ? arr[0] =100 print(arr) print(arr1)  ''' [100   1   2   3   4   5   6   7   8   9  10  11]  [[ 0  1  2  3  4  5]  [ 6  7  8  9 10 11]] '''   ","categories": ["Python"],
        "tags": ["Numpy"],
        "url": "http://localhost:4000/python/Numpy/",
        "teaser": "http://localhost:4000/assets/image/1*cyXCE-JcBelTyrK-58w6_Q.png"
      },{
        "title": "Python Page",
        "excerpt":" \t  파이썬 기본편   [Python] 숫자형 데이터 타입   [Python] 문자열   [Python] 문자열 연산   [Python] In Not in   [Python] 문자열 Indexing &amp; Slicing   [Python] Formatting   [Python] List   [Python] Dictionary   파이썬 머신러닝   [Python] Anaconda &amp; JupyterNotebook   [Python]Numpy-1   [Python]Numpy-2   [Python]ndarray   [Python]Pandas-1   [Python]Pandas-2   ","categories": ["Python"],
        "tags": [],
        "url": "http://localhost:4000/python/PythonPage/",
        "teaser": "http://localhost:4000/assets/image/python.jpg"
      },{
        "title": "[Python] ndarray",
        "excerpt":"ndarray   다차원 ndarray를 만들어 보겠습니다. List도 비슷한 형태를 만들 수 있지만 List는 중첩리스트만 존재합니다.   간단한 예제를 보면서 차이점을 보도록 하겠습니다.   ### List a = [[1,2,3],      [4,5,6]] # python 에서는 2차원 리스트라고 부르지는 않아요 !  arr = np.array(a) print(arr) # [[1,2,3],[4,5,6]] print(arr[1] [1]) # 5  ### ndarray a = [[1,2,3],      [4,5,6]] # 2차원 // 2행 3열 arr = np.array(a, dtype =np.float64)# 지정하지 numpy가 자동으로 판단해서 지정 print(arr) ''' [[1. 2. 3.]  [4. 5. 6.]] '''   ndarray - 차원과 크기   a = [1, 2, 3, 4] arr = np.array(a, dtype=np.float64) # dtype으로 데이터의 속성을 지정할수 있어요 print(arr) #[1. 2. 3. 4.] print(arr.ndim) #ndim &gt; 차원의 개수 : 1 print(arr.shape) # 차원의 개수와 각차원의 요소를 tuple로 표현  \t\t # (4,)    a = [[1, 2, 3],      [4, 5, 6],      [7, 8 ,9],      [10, 11, 12]] arr = np.array(a, dtype=np.float64) print(arr) print(arr.ndim) #ndim &gt; 차원의 개수 : 2 print(arr.shape) # 차원의 개수와 각차원의 요소를 tuple로 표현                  # (4, 3)    a = [[[1, 2, 3],      [4, 5, 6]],      [[1, 2, 3],      [4, 5, 6]]] arr = np.array(a, dtype=np.float64) print(arr) ''' [[[1. 2. 3.]   [4. 5. 6.]]   [[1. 2. 3.]   [4. 5. 6.]]]  ''' print(arr.ndim) #ndim &gt; 차원의 개수 : 3 print(arr.shape) # 차원의 개수와 각차원의 요소를 tuple로 표현                  # (2, 2, 3)   ndarray - shape 변경   a = [[1,2,3], [4,5,6], [7,8,9], [10,11,12]] # 4 X 3 arr = np.array(a, dtype = np.float64) print(arr) print(arr.size) # 12 // 현재 np가 가지고 있는 모든요소의 개수 print(len(arr)) #4 // 첫번째 차원의 요소 개수를 리턴 // 행의 개수를 리턴합니다. print(arr.shape) # (4,3)  arr.shape = (2, 6) # shape을 변경이 가능 print(arr) ''' [[ 1.  2.  3.  4.  5.  6.]  [ 7.  8.  9. 10. 11. 12.]] '''  arr.shape = (3, 2, 2) print(arr) ''' [[[ 1.  2.]   [ 3.  4.]]   [[ 5.  6.]   [ 7.  8.]]   [[ 9. 10.]   [11. 12.]]] '''  arr.shape = (3, 2, 3) # size는 맞춰서 shape이 변경가능 print(arr) ''' --------------------------------------------------------------------------- ValueError  Traceback (most recent call last) &lt;ipython-input-41-11d631f7d9d2&gt; in &lt;module&gt;      14 print(arr)      15  ---&gt; 16 arr.shape = (3, 2, 3)      17 print(arr)  ValueError: cannot reshape array of size 12 into shape (3,2,3) '''   ndarray - 데이터 타입 변경   ndarray를 생성할 때 dtype을 지정해서 만들지만 변경이 가능합니다. 바로 astype 을 통해서 변경이 가능합니다.   하기 예제를 통해서 알아보도록 하겠습니다.   import numpy as np arr = np.array([1.5, 2.3, 8.3, 9.8, 7.7], dtype = np.float64) print(arr) # [1.5 2.3 8.3 9.8 7.7]   result = arr.astype(np.int32) print(result) # [1 2 8 9 7] // 정수형태로 변환되며 버림처리됩니다. print(result.dtype) #int32   ndarray - 만드는 방법   ndarray를 생성할 때 타이핑을 치지않고 명령어를 통하여 만들 수 있습니다.   하기 예제를 통해서 알아보도록 하겠습니다.      import numpy as np arr = np.zeros((3,4)) #0으로 채워서 ndarray를 만들수 있어요 print(arr) ''' [[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]] '''  arr = np.ones((3,4)) print(arr) ''' [[1. 1. 1. 1.] [1. 1. 1. 1.] [1. 1. 1. 1.]] '''  arr = np.full((3,5), 7, dtype=np.float64) print(arr) ''' [[7. 7. 7. 7. 7.] [7. 7. 7. 7. 7.] [7. 7. 7. 7. 7.]] '''  arr = np.empty((3,3))  # 3 X 3 ndarray 를 생성하는데 초기값을 주지않아요 # 내가 원하는 shape의 공간만 설정 #초기화 하지않아 만드는 속도가 빨라서 사용 print(arr) ''' [[ 6.17779239e-31 -1.23555848e-30  3.08889620e-31] [-1.23555848e-30  2.68733969e-30 -8.34001973e-31] [ 3.08889620e-31 -8.34001973e-31  4.78778910e-31]] '''       1. ndarray를 만드는 다른 방법 - _like     arr = np.array([(1,2,3), (4,5,6)]) print(arr) ''' [[1 2 3] [4 5 6]] '''  # 위에서 만든 2 X 3 행렬에 대하여 동일한 size의 행렬을 만들어요 result = np.zeros_like(arr)  print(result) ''' [[0 0 0] [0 0 0]] '''       2.  ndarray를 만드는 다른 방법 - arange     python의 range와 상당히 유사합니다.     주어진 범위 내에서 지정한 간격으로 연속적인 원소를 가진 ndarray를 생성합니다.     하기 예제를 보면서 확인해보록 하겠습니다.     a = range(1,10,1) print(a) # range(1, 10)  arr = np.arange(1,10,1) print(arr) # [1 2 3 4 5 6 7 8 9]       3. ndarray를 만드는 다른 방법 - linspace     linspace 기능을 확인하기 위해서 그래프로 데이터를 그려보도록 하겠습니다. matplotlib module, ` seaborn` 라는 모듈을 이용해서 그래프를 그릴 수 있습니다.     이번시간에는 matplotlib을 사용해보도록 하겠습니다. 이것도 마찬가지로 pip 혹은 conda를 이용해서 설치하&gt;도록 하겠습니다.     conda install matplotlib 의 설치명령어로 터미널을 통해서 설치하도록 하겠습니다.     설치 이후 간단한 예제를 통하여 linspace를 자세하게 알아보도록 하겠습니다.     import numpy as np import matplotlib.pyplot as plt ''' np.linspace(start, stop, num)  start 부터 시작해서 stop의 범위에서 num개의 숫자를  균일한 간격으로 데이터를 생성해서 ndarray를 만드는 함수 '''  arr = np.linspace(0,10,11) print(arr) #[ 0.  1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]  arr = np.linspace(0,10,13) print(arr) ''' [ 0. 0.83333333  1.66666667  2.5 3.33333333  4.16666667    5. 5.83333333  6.66666667  7.5 8.33333333  9.16666667  6.] '''   arr = np.linspace(1,121,31)  #원소간의 간격은 (stop - start) / (num -1)  print(arr)  ''' [  1.   5.   9.  13.  17.  21.  25.  29.  33.  37.  41.     45.  49.  53.\t 57.  61.  65.  69.  73.  77.  81.  85.   89.  93.  97. 101. 105. 109.  58.  117. 121.] '''  plt.plot(arr, \"*\") # 각각의 점들을 *로 표시하여 나타냅니다. plt.show()           난수 기반의 ndarray 생성   총 다섯가지 방법으로 ndarray를 생성할 수 있습니다.   np.random.normal()   정규분포 확률 밀도함수에서 실수 표본을 추출해서 ndarray 생성 (평균, 표준편차)      import numpy as np import matplotlib.pyplot as plt mean = 50 std = 2 arr = np.random.normal(mean, std, (10000,)) # 10000개의 데이터 추출 print(arr) ''' [47.48597904 51.09675807 48.58847913 ... 48.31064207 47.61720963 50.06721122] ''' # 히스토그램  plt.hist(arr, bins = 100) # 히스토그램의 x축의 간격을 100개로 쪼개서 만듦 plt.show()           np.random.rand()   실수를 추출하는데 (0,1) 범위에서 추출하고 균등분포로 추출      arr = np.random.rand(100000) print(arr) plt.hist(arr, bins=100) plt.show()           np.random.randn(d0,d1,d2, …)   실수추출 , 표준정규분포에서 난수를 추출 평균0, 표준편차 1         arr = np.random.rand(100000)    print(arr)    plt.hist(arr, bins=100)    plt.show           np.random.randint(low,high, shape)  균등분포 확률밀도함수에서 난수를 추출하는데 정수값을 난수로 추출         arr = np.random.randint(-100,100,(100000, ))    print(arr)    plt.hist(arr, bins =100)    plt.show()           np.random.random(shape)  [0,1) 균등분포에서 실수 난수를 추출합니다.         arr = np.random.random((100000, ))    print(arr)    plt.hist(arr, bins=100)    plt.show()           Numpy 가 제공하는 랜덤 관련 함수           난수의 재현       하기코드로 작성하면 매번 실행시 마다 새로운 random 값이 도출됩니다.       arr = np.random.randint(0, 100, (10,)) print(arr) # [60 72  4  8 98 88 69 54 83 30]           하지만 랜덤 값도 실제로는 특정 알고리즘의 결과물이기에 초기에 시작값을 설정해주면 항상 같은 랜덤값이 도출됩니다.       np.random.seed(10) # 한번뽑은 랜덤값을 같은값으로 도출되도록 설정 arr = np.random.randint(0, 100, (10,)) print(arr)  ''' [ 9 15 64 28 89 93 29  8 73  0] [ 9 15 64 28 89 93 29  8 73  0] [ 9 15 64 28 89 93 29  8 73  0] [ 9 15 64 28 89 93 29  8 73  0] '''                        ndarray의 순서를 램덤하게 바꿀려면 어떻게 해야하나요?       arr = np.arange(10) print(arr) # [0 1 2 3 4 5 6 7 8 9]     np.random.shuffle(arr) # ndarray 자체가 변형되요! print(arr) # [1 5 2 9 7 0 3 4 6 8]                        ndarray sampling - 일부 무작위로 선택하는 기능.                       np.random.choice(arr, size, replace, p)                        arr : numpy array가 나오거나 혹은 정수가 나올 수 있어요           =&gt; 만약 정수면 정수만 쓰면 : arange(정수) 가 실행               size : 정수값. 샘플의 숫자       replace : Boolean (True, False)           True : 한번 선택한 데이터를 다시 샘플링 가능 (중복 인자)       p(확률) : ndarray. 각 데이터가 샘플링 될 확률을 가지고 있는 ndarray           arr = np.random.choice(5,3,replace = True ) print(arr) #[1 1 3] 값 중복 가능     arr = np.random.choice(5,3,replace = False ) print(arr) #[0 4 1] 값 중복 불가능     arr = np.random.choice(5,10,replace = True,p = [0.2, 0, 0.3, 0.4, 0.1]  ) print(arr) #[0 2 0 3 2 0 3 0 2 3] 1은 0%이기 때문에 나올 수가 없음           ndarray는 shape을 가지고 있어요!   # shape 속성의 값을 바꾸어서 ndarray의 형태를 변경하는 것은 그다지 좋지 않아요! # reshape() 항수를 이용해서 처리합니다.  import numpy as np arr = np.arange(0,12,1) arr1 = arr.reshape(4,3) # 새로운 ndarray를 만드는게 아니라 view를 생성. print (arr) print (arr1)  ''' [ 0  1  2  3  4  5  6  7  8  9 10 11]  [[ 0  1  2]  [ 3  4  5]  [ 6  7  8]  [ 9 10 11]] '''  arr[0] =100 print(arr)  print(arr1) #데이터 공유  ''' [100   1   2   3   4   5   6   7   8   9  10  11]  [[100   1   2]  [  3   4   5]  [  6   7   8]  [  9  10  11]] '''  arr = np.arange(0,12,1) arr1 = arr.reshape(-1,4) print(arr1)  ''' [[ 0  1  2  3]  [ 4  5  6  7]  [ 8  9 10 11]] '''  arr = np.arange(0,12,1) arr1 = arr.reshape(2,3,-1) print(arr1) ''' [[[ 0  1]   [ 2  3]   [ 4  5]]   [[ 6  7]   [ 8  9]   [10 11]]] '''   arr = np.arange(0,12,1) arr1 = arr.reshape(2,6).copy() # 데이터 공유하지않고 새로운 ndarray를 제작하려면 ? arr[0] =100 print(arr) print(arr1)  ''' [100   1   2   3   4   5   6   7   8   9  10  11]  [[ 0  1  2  3  4  5]  [ 6  7  8  9 10 11]] '''   ","categories": ["Python"],
        "tags": ["Numpy","ndarray"],
        "url": "http://localhost:4000/python/ndarray/",
        "teaser": "http://localhost:4000/assets/image/1*cyXCE-JcBelTyrK-58w6_Q.png"
      },{
        "title": "[Python] Numpy-2",
        "excerpt":"Numpy -2   오늘은 numpy 에 대하여 조금 더 알아보도록 하겠습니다.   Reshape vs Resize   numpy 내장 함수인 reshape 와 resize에 대하여 알아보겠습니다. reshape 와 resize는 행렬의 array를 shape을 변경하는 점에서 동일하나 차이점이 한가지가 있습니다.   reshape 이전의 행렬의 인자의 개수와 변경될 인자의 개수가 동일해야만 사용할 수 있습니다.   하지만 resize 경우에는 상관없이 사용가능합니다. 이전에 비해 인자가 부족할 경우 나머지 요소를 0으로 채우고, 남는경우에는 필요한 요소를 제외하고는 전부다 버려 행렬을 완성합니다.   하기 예제를 보며 차이점을 알아보도록 하겠습니다.   import numpy as np  #정수형태의 난수를 이용해서 (3,4) shape을 가지는 ndarray를 생성할 꺼에요! np.random.seed(10) arr = np.random.randint(0,10,(3,4)) print(arr)  result = arr.resize(2,6) # 원본을 변경 print(result) # None print(arr)  arr.resize(3,5)  # reshape은 안됨 error 하지만 resize는 나머지 요소를 0으로 맞춤 print(arr)  arr.resize(2,2)  # 요소수가 줄면 나머지데이터를 버립니다. print(arr)   Indexing &amp; Slicing   Indexing과  Slicing 모두 List 혹은 문자열에서 많이 사용하였습니다. 하지만 Numpy에서도 비슷하게 사용할 수 있습니다.   자세한 내용은 하기 코드를 보면서 익혀보도록 하겠습니다.   Indexing   import numpy as np arr = np.arange(10,20,1) print(arr)  ndarray의 각요소를 축력하려면 어떻게 해야하나요? for tmp in arr:     print(tmp)  for (idx, tmp) in enumerate(arr):     print('인덱스 : {}, 데이터 : {}'.format(idx, tmp)) ''' 인덱스 : 0, 데이터 : 10 인덱스 : 1, 데이터 : 11 인덱스 : 2, 데이터 : 12 인덱스 : 3, 데이터 : 13 인덱스 : 4, 데이터 : 14 인덱스 : 5, 데이터 : 15 인덱스 : 6, 데이터 : 16 인덱스 : 7, 데이터 : 17 인덱스 : 8, 데이터 : 18 인덱스 : 9, 데이터 : 19 '''   Slicing   arr = np.arange(10,20,1) print(arr[3]) # 13 print(arr[1:4]) # slicing은 원본의 형태를 그대로 가져옴 print(arr[:-1]) #[10 11 12 13 14 15 16 17 18] print(arr[1:-1:2]) #[11 13 15 17] ,없이 표현 arr = np.arange(1,17,1).reshape(4,4).copy() print(arr) ''' [[ 1  2  3  4]  [ 5  6  7  8]  [ 9 10 11 12]  [13 14 15 16]] ''' print(arr[1,2]) # 7 print(arr[1][2]) # 7  print(arr[2,:]) #[ 9 10 11 12] print(arr[1:3,:]) ''' [[ 5  6  7  8]  [ 9 10 11 12]] ''' print(arr[1:3,:2]) ''' [[ 5  6]  [ 9 10]] '''   Boolean indexing &amp; Fancy indexing   Numpy에는 특수한 indexing 방식이 있습니다.  Boolean indexing 과 Fancy indexing 입니다.   먼저 Boolean indexing 부터 알아보도록 하겠습니다.   Boolean indexing   True, False로 구성된 Boolean mask를 이용하여 지정하는 방식입니다. boolean mask의 True에 해당하는 index 만을 조회하는 방식으로도 활용이 가능합니다.  즉 boolean indexing은 ndarray의 각 요소의 선택여부를 결정할 수 있습니다.   예제를 통하여 알아보도록 하겠습니다.   import numpy as np np.random.seed(1) arr = np.random.randint(0,10,(5,)) print(arr) # [5 8 9 5 0] print(arr % 2) # [1 0 1 1 0] print(arr % 2 == 0) # [False  True False False  True] =&gt; boolean mask print(arr[arr % 2 == 0]) # [8 0] =&gt; boolean indexing   Fancy indexing   ndarray에 index배열을 전달하여 배열요소를 참조하는 방식입니다.   예제를 통하여 알아보도록 하겠습니다.   import numpy as np arr = np.arange(0,12,1).reshape(3,4).copy() print(arr) print(arr[2,2]) # indexing : 10 print(arr[1:2, 2]) # slicing : [6] print(arr[1:2, 1:2]) # slicing : [[5]] =&gt; 차원 주의 !! print(arr[[0,2],2]) # [ 2 10] print(arr[[0,2],2:3])  ''' [[ 2]  [10]] ''' # 그렇다면 우리 다음의 2차원 ndarray를 추출해 보아요!! ''' [[1 3]  [9 11]] '''  print(arr[[0,2],[1,3]]) #[ 1 11] 행과 열에 동시에 fancy indexing을 할수가 없어요 !  # 해결방법 1 print(arr[[0,2]][:,[1,3]]) ''' [[1 3]  [9 11]] '''  # 해결방법 2 - numpy 가 함수를 하나 제공해줘요! print(arr[np.ix_([0,2],[1,3])]) ''' [[1 3]  [9 11]] '''   ndarray의 사칙연산과 행렬곱   행렬도 행렬간의 덧셈, 뺄쎔, 나눗셈, 곱셈, 그리고 행렬곱을 실시할 수 있습니다.   행렬곱은 numpy에세 제공하는 dot product를 사용하여 쉽게 구할 수 있습니다.   예제를 통하여 알아보도록 하겠습니다.   import numpy as np arr1 = np.array([[1,2,3],[4,5,6]]) arr2 = np.array([[7,8,9],[10,11,12]]) # python에서 list 할때.. + 얀산자는 concatenation!! # ndarray에서 연산자는 vector, matrix연산.. # ndarray의 사칙연산의 기본 전제는.. shape이 같아야 연산이 성립 print(arr1 + arr2) ''' [[ 8 10 12]  [14 16 18]] ''' arr2 = 3   print(arr1 + arr2) # 수행이 되요 !! =&gt; ndarray가 broadcatin 을 수행 # shape 이 맞지않는 경우 ndarray 가 broadcating을 수행 # arr2 = [[3 3 3]  #         [3 3 3]]  arr2 = np.array([1,2,3])  print(arr1 + arr2)  ''' [[2 4 6]  [5 7 9]] '''  arr2 = np.array([1,2]) # shape을 맞출수가 없음 =&gt; 1,2,1,2 이런식으로 복제가 실행되기 떄문에   print(arr1 + arr2) # error arr1 = np.array([[1,2,3],[4,5,6]]) arr2 = np.array([[7,8,9],[10,11,12]])  ## 행렬곱 연산!!  print(arr1 * arr2) # 단순 곱셈만 실행 ''' [[ 7 16 27]  [40 55 72]] '''  # 두 행렬간의 행렬곱은 np.dot(), np.matmul()로 수행이 가능해요!! # np.dot(A, B)에서 A행렬의 열 vector와 B행렬의 행 Vector의 size가 같아야 해요! # 만약 크기가 다르면 reshape() 이나 resize()나 # 이런것들을 이용해서 크기를 맞추고 연산을 수행해야 해요!!  arr1 = np.array([[1,2,3],[4,5,6]]) arr2 = np.array([[7,8],[9,10],[11,12]]) print(np.dot(arr1, arr2))  # 왜 이런 행렬곱 연산을 알아야 하나요?? # 만약에 행렬곱이 없으면 Matrix 연산은 같은 크기로만 연산을 수행해야 해요!! # 하지만 행렬곱 연산을 이용하면 # 행렬곱 조건만 만족시키면 다양한 크기의 행렬을 우리가 연속적으로 # 이용해서 특정 작업을 수행할 수 있어요 !! # 머신러닝, 이미지처리쪽에서 사용되요!! # 예) 입력 : 32 X 32 matrix (이미지파일) #    출력 : 32 X 10 matrix (다양한 처리가 적용된 이미지) #    행렬곱 : (32 X 32) dot(32 X 128) dot (128 X 64) dot (64 X 10 ) = (32 X 10)   Transpose   Transpose (전체행렬)에 대하여 알아보도록 하겠습니다. 전치행렬은 행과 열을 바꾼 행렬을 의미하며 윗첨자로 T를 사용합니다.   예제를 통하여 알아보도록 하겠습니다.   import numpy as np arr = np.array([[1,2,3],[4,5,6]]) # 2 X 3 ndarray print(arr) t_arr = arr.T print(t_arr) arr[0,0] = 100 print(arr) print(t_arr)   arr = np.array([1,2,3,4]) # vector (1차원 ndarray) t_array = arr.T.reshape(4,1) print(t_array)   Numpy iterator   iterator 의 동작방식입니다. 간단하게 행렬의 요소들을 출력하는 방식이라고 생각하시면 되겠습니다.   For VS iterator   import numpy as np  arr = np.array([1,2,3,4,5])  # for문을 이용하면 편해요!! for tmp in arr:     print(tmp, end=' ') # 1 2 3 4 5   # 일단은 불편하지만 이 작업을 iterator를 이용해서 구현해보겠습니다. # 각각의 칸을 지칭하는 것이 iterator  arr = np.array([1,2,3,4,5])  it = np.nditer(arr, flags=['c_index']) # flags 1차원인경우 'c_index'   while not it.finished: # iterator 가 지정하는 위치가 끝이 아닐동안 반복     idx = it.index # iterator가 현재 가리키는 곳의 index숫자를 가져와요!     print(arr[idx], end=' ')     it.iternext() # iterator를 다음요소로 이동시키는 작업을 해요 !!      ################  # 2차원 ndarray에 대해서 각 요소를 순서대로 출력해보아요!! # 요소를 순서대로 출력 =&gt; 0행0열 &gt; 0행1열 &gt; 0행2열 &gt; 1행0열 &gt; 1행1열 &gt; 1행2열 arr = np.array([[1,2,3],[4,5,6]])  print(arr)  # 요소를 하나씩 뽑아서 순서대로 출력해보세요!! for i in arr:     for x in i:         print(x, end=' ')          for row in range(arr.shape(0)):     for col in range(arr.shape(1)):         print(arr[row,col], end=' ')            it = np.nditer(arr, flags=['multi_index']) # flags 1차원인경우 'c_index'  while not it.finished:     idx = it.multi_index     print(arr[idx], end=' ')     it.iternext()   ndarray 비교연산   사칙연산과 마찬가지로 비교연산도 같은 index끼리 수행됩니다.   np.random.seed(0) arr1 = np.random. randint(0,10,(2,3)) arr2 = np.random. randint(0,10,(2,3))  print(arr1) print(arr2) print(arr1 == arr2) # boolena 형 마스크  arr1 = np.arange(10) arr2 = np.arange(10) print(np.array_equal(arr1, arr2)) # True False 로 표현   Numpy  집계함수 &amp; axis (축)   import numpy as np arr = np.arange(1,7,1).reshape(2,3).copy() print(arr)  print(arr.sum()) print(np.sum(arr)) print (np.cumsum(arr)) #누적합 #피보나치 print(np.mean(arr)) # 평균 print(np.max(arr)) # 최대값 print(np.min(arr)) # 최소값 print(np.argmax(arr)) # 최대값을 찾고 최대값의 index를 반환 순번으로 나타냄 print(np.argmin(arr)) # 최대값을 찾고 최소값의 index를 반환 순번으로 나타냄 print(np.std(arr)) # 표준편차 1.707825127659933 print(np.exp(arr)) # 자연상수 제곱 print(np.log10(arr)) # 로그 #이런 수많은 numpy의 집게함수와 수학함수가 우리에게 제공되요 !! #Numpy의 모든 집계함수는 axis를 기준으로 계산되요!! # np.sum() # 만약 axis를 지정하지 않으면.. axis는 None으로 설정되고.. # 함수의 대상범위를 전체 ndarray로 지정하게 되요!   # axis를 어떻게 설정하고 어떤 효과가 나타나나요??  # 1차원 ndarray를 생성. arr = np.array([1,2,3,4,5]) print(np.sum(arr)) # axis를 지정하지 않았기 떄문에 전체 ndarray를 대상으로 sum()수행 # 1차원은 축이 1개, 2차원은 축이 2개, 3차원은 축이 3개존재 # 1차원인 경우 axis = 0 열방향 !! 가로방향!! # print(arr.sum(axis=0)) # print(arr.sum(axis=1)) # error  # 2차원 ndarray를 생성. arr = np.array([[1,2,3],[4,5,6]]) print(arr.sum(axis=0)) #2차원에서 axis=0 이면 행방향!! &gt; 세로방향 [5 7 9] print(arr.sum(axis=1)) #2차원에서 axis=0 이면 열방향!! &gt; 가로방향 [6 15] print(arr.argmax(axis=1)) #2차원에서 axis=0 이면 열방향!! &gt; 가로방향 [6 15]   np.random.seed(1) arr1 = np.random.randint(0,10,(2,2,3)) print (arr1) print(arr1.sum(axis=0))  # 3차원에서 axis=0은 =&gt; depth방향 # 3차원에서 axis=1은 =&gt; 행 / 세로방향 # 3차원에서 axis=2은 =&gt; 열 / 가로방향   집계함수를 사용해야하는 이유!   처리하는 시간 및 메모리 사용이 적어지는 이유가 가장 큽니다. 앞서 본대로 정답을 구하는 방식은 여러가지가 있습니다. 다만 처리하는 시간 및 사용하는 메모리가 한정될 경우 최적의 경로를 통하여 코드를 작성해야하는데 집계함수를 이용하면 최대한 시간 및 메모리를 절약할 수 있습니다.   %% time  을 사용해서 소요시간비교를 해보도록 하겠습니다. %% time 은 jupyter notebook에서만 사용가능합니다.   for 문   %%time  # for 문을 이용해서 합을 구하거나 arr = np.arange(100000, dtype = np.float64) result = 0 for tmp in arr:     result += tmp print(result)  # 4999950000.0 # CPU times: user 28.6 ms, sys: 1.27 ms, total: 29.9 ms # Wall time: 29.1 ms   집계함수   %%time  # 집계함수를 이용해서 구할 수 있어요!! arr = np.arange(100000, dtype = np.float64) print(arr.sum())  # 4999950000.0 # CPU times: user 485 µs, sys: 219 µs, total: 704 µs # Wall time: 379 µs   ndarray 정렬   numpy array는 axis를 기준으로 정렬하는 sort()함수를 제공합니다. 만약 axis를 지정하지 않으면  -1값으로 지정하며 마지막 axis를 지정합니다.   정렬하는 방법은 두 가지 방법이 있습니다.      np.sort() : 정렬된 결과 ndarray를 리턴   arr.sort() : 원본을 정렬 return값은 None   import numpy as np arr = np.arange(10) arr = np.arange(10) arr2 = arr.sort() arr3 = np.sort(arr) print(arr2) # None print(arr3) # [0 1 2 3 4 5 6 7 8 9]   print(arr) np.random.shuffle(arr) print(arr) print(np.sort(arr)) #오름 차순으로 정렬 (default 가 오름차순) # ndarray는 특수한 indexing 을 제공 &gt; 역순으로 정렬하기 위한 indexing 을 제공 print(np.sort(arr)[::-1])   arr = np.arange(1,17) np.random.shuffle(arr) arr = arr.reshape(4,4).copy()  print(arr) ''' [[ 4 13  7  6]  [10  2  5 11]  [12  3  8  1]  [14 16 15  9]] ''' print(np.sort(arr, axis = 0)) ''' [[ 4  2  5  1]  [10  3  7  6]  [12 13  8  9]  [14 16 15 11]] ''' print(np.sort(arr, axis = 1)) ''' [[ 3  7 10 14]  [ 4  5 12 13]  [ 1  2  6 16]  [ 8  9 11 15]] '''   ndarray 행렬 추가 및 제거   오늘은 행렬의 요소를 추가 및 제거하는concatenate 와 delete 에 대하여 알아보겠습니다.   예제를 보면서 쉽게 이해해보도록 하겠습니다.   concatenate()   #ndarray에 row(s) 혹은 column(s)을 추가하기 위한 함수 #concatenate()  import numpy as np  arr = np.array([[1,2,3],[4,5,6]]) # 2X3 ndarray new_row = np.array([7,8,9])  # arr에 new_row vector를 하단에 붙일거에요!! # 결과적으로 3 X 3 matrix를 생성할꺼에요!! # matrix끼리만 서로 붙습니다. # result = np.concatenate(어떤것을 서로 붙일지 , 행으로 붙일지 열로 붙일지..) result = np.concatenate((arr, new_row.reshape(1,3)) , axis = 0) print(result) ''' [[1 2 3]  [4 5 6]  [7 8 9]] '''   delete()   # delete() 함수  # axis를 기준으로 행과 열을 삭제할 수 있어요 !! # 만약 axis를 지정하지 않으면 1차원 배열로 변환 후 삭제 # 원본은 변경하지 않고 처리가 된 새로운 배열을 return  import numpy as np np.random.seed(1)  arr = np.random.randint(0, 10, (3,4)) print(arr) ''' [[5 8 9 5]  [0 0 1 7]  [6 9 2 4]] '''  result = np.delete(arr, 1) # axis가 설정되지 않았기 때문에 1차배열고 자동 변경된후 인덱스를 삭제 print(result) #[5 9 5 0 0 1 7 6 9 2 4]  result = np.delete(arr, 1, axis = 0)  print(result) ''' [[5 8 9 5]  [6 9 2 4]] '''   오늘은 Numpy에 대하여 자세하게 알아보았습니다. 질문이 있으시면 아래 댓글에 남겨주세요!  ","categories": ["Python"],
        "tags": ["Numpy"],
        "url": "http://localhost:4000/python/Numpy_2/",
        "teaser": "http://localhost:4000/assets/image/1*cyXCE-JcBelTyrK-58w6_Q.png"
      },{
        "title": "[Python] Pandas-1",
        "excerpt":"Pandas   오늘은 Pandas에 대하여 알아보겠습니다. Pandas는 ndarray(Numpy)를 기본 자료 구조로 사용하며 두 개의 또 다른 자료구조Series 와 DataFrame를 이용합니다.   먼저 Pandas를 설치하고 시작하도록 하겠습니다. 하기 명령어를 터미널에서 입력하여 설치합니다.   $conda install pandas   설치가 완료되었다면 예제를 통하여 자세하게 알아보도록 하겠습니다.   Series   동일한 데이터 타입의 복수개의 성분으로 구성되는 자료구조 ( 1차원 )   import pandas as pd import numpy as np  # ndarray arr = np.array([-1,4,5,99], dtype=np.float64) # print(arr)  # pandas의 Series부터 만들어 보아요! s = pd.Series([-1,4,5,99], dtype=np.float64) print(s) ''' 0    -1.0 1     4.0 2     5.0 3    99.0 ''' print(s.values) # [-1.  4.  5. 99.] ndarray print(s.index) # RangeIndex(start=0, stop=4, step=1) RangeIndex객체로 만들어짐 print(s.dtype) # float64  # Series 생성 시 index를 별도로 지정할 수 있어요! =&gt; list, ndarray 로 지정할 수 있어요! # 숫자 index는 기본으로 사용이 가능!! s = pd.Series([-1, 8, 5, 10 ], dtype=np.float64, index=['c','b','a','k']) print(s) ''' c    -1.0 b     8.0 a     5.0 k    10.0 dtype: float64 ''' print(s[0]) # -1.0 print(s['c']) # -1.0  # 그러면 만약 index를 우리가 새로 지정해서 사용할 때 # 같은 index가 있으면 어떻게 되나요??  s = pd.Series([-1, 8, 5, 10 ], dtype=np.float64, index=['c','b','c','k']) print(s['c']) ''' c   -1.0 c    5.0 dtype: float64 '''  print(s['c'].values) # [-1.  5.]  # Series에서 Slicing 도 가능할까요?? print(s[1:3]) # Series로 결과 return ''' b    8.0 c    5.0 dtype: float64 '''  print(s['b':'k']) # 앞 뒤 범위 둘다 포함 ''' dtype: float64 b     8.0 c     5.0 k    10.0 dtype: float64 '''  # Boolean Indexing print(s[s%2 == 0]) # 짝수만 출력!! ''' b     8.0 k    10.0 '''  # Fancy Indexing print(s[[0,2,3]]) ''' c    -1.0 c     5.0 k    10.0 '''  # Numpy에서 했던 여러가지 작업들이 그대로 사용될 수 있어요 !! print(s.sum()) # 22.0  s = pd.Series([1,2,3,4]) print(s)  # 새로운 데이터를 Series에 추가하려면 ?? s[4] = 100 print(s)  s[6] = 100 # 5를 제외해도 6이 새로 생김 print(s) ''' 0      1 1      2 2      3 3      4 4    100 6    100 '''  # Series에서 특정 index를 삭제하려면 ?? s = s.drop(2) print(s) ''' 0      1 1      2 3      4 4    100 6    100 dtype: int64 '''  # python의 dictionary를 이용해서 Series를 만들 수 있어요 !! # dictionary의 key가 index가 되요!!  import numpy as np import pandas as pd my_dict = {'서울' : 1000, '부산' : 2000 , '제주' : 3000} s =pd.Series(my_dict) print(s) ''' 서울    1000 부산    2000 제주    3000 dtype: int64 '''  s.name = '지역별 가격 데이터!!' #  Name: 지역별 가격 데이터!! // 시리즈의 이름을 부여가 가능 s.index.name = '지역명' print(s) ''' 지역명 서울    1000 부산    2000 제주    3000 Name: 지역별 가격 데이터!!, dtype: int64 '''   DataFrame   엑셀에서 Table 과 같은 개념입니다. Database의 Table 이며 여러개의 Series로 구성됩니다. (2차원)   # Pandas DataFrame 생성 !! # python의 dictionary를 가지고 만들어요!!  # dictionary 로 DataFrame을 생성할때 데이터의 개수가 맞지 않으면 Error발생 # dictionary의 key가 DataFrame의 column으로 들어가게 됩니다. # DataFrame은 Series의 집합으로 구성됩니다!! (각각의 column이 Series)  import numpy as np import pandas as pd  # dictionary data = {'names' : ['홍길동', '아이유', '김연아', '강감찬', '이순신'],          'year' : [2015, 2019, 2020, 2013, 2017],         'points' : [3.5, 1.5, 2.0, 3.4, 4.0]        }  # DataFrame을 생성 df = pd.DataFrame(data)  # Data Frame 을 출력할떄는 display()를 이용해서 출력하느 것이 좋아요! display(df)  ''' names\tyear\tpoints 0\t홍길동\t2015\t3.5 1\t아이유\t2019\t1.5 2\t김연아\t2020\t2.0 3\t강감찬\t2013\t3.4 4\t이순신\t2017\t4.0 '''  # 기억해야 하는 속성을 알아보아요!! print(df.shape) # tuple 로 표현되구요! (5,3) print(df.size) # 15 모든 요소의 개수 print(df.ndim) # 차원   # DataFrame의 index, values, columns import numpy as np import pandas as pd  # dictionary data = {'names' : ['홍길동', '아이유', '김연아', '강감찬', '이순신'],          'year' : [2015, 2019, 2020, 2013, 2017],         'points' : [3.5, 1.5, 2.0, 3.4, 4.0]        } df = pd.DataFrame(data) display(df) print(df.index) # RangeIndex(start=0, stop=5, step=1) print(df.columns) # Index(['names', 'year', 'points'], dtype='object') print(df.values) # 2차원 ndarray ''' [['홍길동' 2015 3.5]  ['아이유' 2019 1.5]  ['김연아' 2020 2.0]  ['강감찬' 2013 3.4]  ['이순신' 2017 4.0]] '''  df.index.name = '학번' df.columns.name = '학생정보' display(df) ''' 학생정보\tnames\tyear\tpoints 학번\t\t\t 0\t홍길동\t2015\t3.5 1\t아이유\t2019\t1.5 2\t김연아\t2020\t2.0 3\t강감찬\t2013\t3.4 4\t이순신\t2017\t4.0 '''    DataFrame 을 생성하는 다양한 방법   1. CSV 파일을 이용해서 DataFrame을 생성   CSV 파일을 하나 만들어서 DataFrame을 생성해 보아요!! Student.csv를 다운 받아서 사용해보겠습니다.   import pandas as pd  df = pd.read_csv('./data/student.csv') display(df)   2. Database를 이용해서 DataFrame을 생성   MySQL을 사용하여 데이터를 구축한 후 pandas의 DataFrame으로 읽어오도록 하겠습니다.   SQL 파일은 _BookTableDump.sql 을 다운받아서 사용해보도록 하겠습니다.   # 여러가지 DBMS제품들이 있어요 # 데이터베이스?? # 데이터베이스는 일반적으로 정제된, 연관성이 있는 자료의 집합. #우리는 이런 데이터베이스를 활용하고 싶어요! CS분야에서는 데이터베이스가 파일에 저장되어 있어요 #이런 데이터베이스를 다루기 위한 프로그램이 필요해요! # 이런 프로그램들을 DBMS(DataBase Management System) 라고해요! # Oracle, Cybase, DB2, Informix, MySQL, SQLite, etc... # MySQL을 가지고 데이터베이스를 구축한 후 이 데이터를 pandas의 DataFrame으로 가져올꺼에요! # MySQL이라는 DBMS로 데이터베이스를 생성해서 데이터베이스를 구축해요!! # 그 안에 있는 데이터를 추축해서 DataFrame으로 생성! # 사용할 MySQL버전은 5.6 버전을 사용할 꺼에요!  # 데이터를 정제하고 전처리를 하는데 pandas가 이용될 꺼에요!! # 1. MySQL 5.6버전을 다운로드한 후 바탕화면에 압축을 풀어요!  # 2. bin폴더로 이동한 후./mysqld를 실행해서 MYSQL DMBS Sever를 시작해요! # 3. MySQL Server를 실행시켰기 때문에 MySQL console에 들어갈 수 있어요! # 4. MySQL Server를 정상적으로 중지하려면 새로운 command창을 띄워요! 다시 해당 bin 폴더로 이동 # ./mysqladmin -u root shutdown # 5. MySQL Server를 다시 기동시킨 후 # 6. MySQL 시스템에 접속해요! =&gt; command창을 열어서 다음의 명령어를 ./mysql -u root # 7. 새로운 사용자를 생성해요!! #     =&gt; create user data identified by \"data\"; # 8. 새로운 사용자를 하나 더 생성해야 합니다. #     =&gt; create user data@localhost identified by \"data\"; # 9. 데이터베이스를 생성해야 해요!! #     =&gt; create database library; # 10. 생성한 데이터베이스(library)에 대한 사용권한을 새롭게 생성한 data 사용자에게 부여 #     =&gt; grant all privileges on library.* to data; #     =&gt; grant all privileges on library.* to data@localhost; # 11. 지금까지 작업한 권한부여작업을 flush #     =&gt; flush privileges; # 12. 작업이 완료되었으니 console 을 종료 #     =&gt; exit; # 13. 제공된 파일을 이용해서 실제 사용할 데이터베이스를 구축해보아요!! # 14. 파일을 복사한 다음 다음의 명령어를 도스창에서 실행! # mysql -u data -p library &lt; _BookTableDump.sql # mysql -u '유저명' -p '라이브러리명' &lt; _BookTableDump.sql  ## 데이터 베이스 구축이 끝났으니... pandas로 데이터베이스에 접속해서 데이터를 가져다가 DataFrame으로 만들어 보아요! # 그런데 특별한 기능을 사용하고 있어요. python으로 MySQL database를 사용하는 기능을 하려고해요 # 이 기능을 하기위한 package(module)이 필요해요! 이 모듈을 설치해야 해요! &gt; pip install pymysql  import pymysql.cursors import pandas as pd  # pymysql이라는 module을 이용해서 데이터 베이스에 연결   # mysql -u data -p library &lt; _BookTableDump.sql # mysql -u '유저명' -p '라이브러리명' &lt; _BookTableDump.sql  conn = pymysql.connect(host= 'localhost',                       user = 'data', # '유저명'                       password = 'data',                       db='library', # '라이브러리명'                       charset='utf8')  # 데이터베이스에 접속되면 SQL문을 실행시켜서 Database로 부터 # 데이터를 가져온 후 이놈을 DataFrame으로 생성  sql = 'select btitle, bauthor, bprice from book' df = pd.read_sql(sql, con = conn) display(df)   ","categories": ["Python"],
        "tags": ["Pandas","MySQL"],
        "url": "http://localhost:4000/python/Pandas/",
        "teaser": "http://localhost:4000/assets/image/1200px-Pandas_logo.svg.png"
      },{
        "title": "[Python] Pandas-2",
        "excerpt":"Pandas - 2   Pandas - 1에서는 전반적인 Pandas의 활용에 대하여 알아보았습니다. 이번시간에는 본격적으로 좀더 자세하게 알아보도록 하겠습니다.   Database안에 Table을 사용하는 방법이 크게 2가지가 있습니다.      Django에서 사용했던 ORM방식 ( Model 을 이용해서 Table을 사용하는 방법)  =&gt; SQL이라고 불리는 Database 언어를 몰라도 Table을 사용할 수 있습니다.   일반적으로 SQL 구문을 이용해서 Database안의 Table을 사용합니다.  =&gt; SQL 구문을 알아야 table에서 내가 원하는 데이터를 추출할 수 있습니다.   그렇다면 간단하게 SQL 구문을 알아보도록 하겠습니다.   SQL 문법   import pymysql.cursors import pandas as pd  # pymysql이라는 module을 이용해서 데이터 베이스에 연결  conn = pymysql.connect(host= 'localhost',                       user = 'data',                       password = 'data',                       db='library',                       charset='utf8')  # 데이터베이스에 접속되면 SQL문을 실행시켜서 Database로 부터 # 데이터를 가져온 후 DataFrame으로 생성 # sql은 대소문자를 구분하지 않음 # WHERE 조건  # sql = 'SELECT btitle, bprice FROM book WHERE bprice &gt;30000'  # 책 제목에 특정 키워드가 들어가 있는 책들만 골라오고 싶어요! (패턴매칭) # sql = 'SELECT btitle, bprice FROM book WHERE btitle like \"%java%\"' sql = 'SELECT btitle, bprice FROM book WHERE btitle  \"%여행%\"'  df = pd.read_sql(sql, con = conn) display(df)      JSON FILE 로 저장하기   Database나 CSV파일로부터 데이터를 읽어들여서 DataFrame으로 만들어 보았습니다. 이렇게 만든 DataFrame을 JSON으로 저장할 수 있습니다. JSON 파일로 저장할 때 4가지 방식이 있어요!! Database안의 book table에서 원하는 내용의 데이터를 가져온 후 DataFrame으로 만들어서  JSON 파일로 저장해 보겠습니다.   import pymysql.cursors import pandas as pd  conn = pymysql.connect(host= 'localhost',                       user = 'data',                       password = 'data',                       db='library',                       charset='utf8')  sql = 'SELECT btitle,bauthor, bprice FROM book WHERE btitle like \"%여행%\"'  df = pd.read_sql(sql, con = conn)  display(df)  # DataFrame을 json파일로 저장할 때 총 4가지 서로 다른 형식이 존재. # Unicode로 파일을 생성한 후 데이터를 저장해야 한글이 정상 처리가 되요! # 파일을 저장할 폴더는 미리 생성이 되어 있어야 합니다.!!  # with : 일반적으로 파일 처리할 때 순서는 파일열기 - 내용쓰기 - 파일닫기 이순서... #        with 구문을 이용하면 resource의 close처리(해제처리)가 자동으로 이루어져요! with open('./data/json/books_columns.json', 'w', encoding='utf8') as file:     df.to_json(file, force_ascii=False, orient = 'columns')     # orient = columns로 설정하면 df의 column이 json의 key값으로 들어가요.      with open('./data/json/books_records.json', 'w', encoding='utf8') as file:     df.to_json(file, force_ascii=False, orient = 'records')     # orient = records로 설정하면 df의 각각의 record들의 첫번째 행이 json의 key값으로 들어가고      # dictionary 형태가 리스트 로 감싸져서 나타납니다.      with open('./data/json/books_index.json', 'w', encoding='utf8') as file:     df.to_json(file, force_ascii=False, orient = 'index')     # orient = index로 설정하면 df의 index이 json의 key값으로 들어갑니다.      with open('./data/json/books_values.json', 'w', encoding='utf8') as file:     df.to_json(file, force_ascii=False, orient = 'values')     # orient = values로 설정하면 df의 value값이 리스트형태로 저장됩니다.   JSON FILE 불러오기   데이터베이스나 CSV파일을 통해 받은 데이터를 Json파일로 저장하는 것까지 해보았습니다. 이번에는 저장된 JSON파일을 불러와서 DataFrame을 생성해보겠습니다.   # JSON 파일을 읽어서 DataFrame을 생성해 보아요!! import numpy as np import pandas as np import json  # 우리가 가지고 있는 json 파일을 open 해서 json내용을 읽어 들어야 해요! with open('./data/json/books_columns.json', 'r', encoding ='utf-8') as file:     dict_books = json.load(file) # json 데이터를 python의 dictionary로 저장 print(dict_books) print(type(dict_books)) #&lt;class 'dict'&gt; df = pd.DataFrame(dict_books) display(df)      ","categories": ["Python"],
        "tags": ["Pandas","Json"],
        "url": "http://localhost:4000/python/Pandas_2/",
        "teaser": "http://localhost:4000/assets/image/1200px-Pandas_logo.svg.png"
      },{
        "title": "[Algorithm] 계산복잡도",
        "excerpt":"계산 복잡도   오늘은 알고리즘의 복잡도에 대하여 알아보겠습니다.   알고리즘을 공부하는 이유는 좀더 빠르고 효율적이게 하기 위함입니다. 이번시간에는 저희가 짠 코드가 얼마만큼의 복잡도를 가지고 있는지 빅 오 개념을 배워보도록 하겠습니다.   간단한 예제를 보도록 하겠습니다. 1부터 n까지의 합을 구하는 코드를 for 문을 이용하여 구해보도록 하겠습니다.   s = 0 for i in range(1, n+1):   s += i  print(s)   s는 n번 반복하여 1부터 n까지의 합을 구할 수 있습니다. n이 커질수록 점점 계산의 복잡도가 커지게 됩니다. 이떄 알고리즘의 계산 복잡도를 O(n)이라고 표현합니다. 만약 1부터 2n 까지의 합을 구한다면 복잡도는 O(2n) 만큼으로 증가하게됩니다.   하지만 조금이상하죠?? 저희는 고등교육에서 수열의 합이라는 것을 통해 반복하지 않아도 1부터 n까지의 수를 간단한 공식을 통하여 구할수 있었습니다. 바로 n(n+1) / 2 를 통해서 바로 값을 구할 수 있었습니다. 이때의 계산복잡도는 O(1)입니다. n의 크기와 상관없이 덧셈, 곱셈, 나눗셈으로 한번에  표현할 수 있기때문에 O(3)이 아닌 O(1)로 표현하는 것입니다. 이렇게 최적화된 알고리즘을 사용하거나 수학을 이용하면 좀더 효율적으로 프로그래밍을 할 수 있습니다.  ","categories": ["Algorithm"],
        "tags": ["complexity"],
        "url": "http://localhost:4000/algorithm/BigO/",
        "teaser": "http://localhost:4000/assets/image/Algorithm.png"
      },{
        "title": "[Python] Machin Learning",
        "excerpt":"Machine Learning   Machine Learning 은 학습방법에 따라서 크게 4가지로 분류합니다.          지도학습(Supervised Learning)            비지도학습(Unsupervised Learning)            준지도학습(SemiSupervised Learning)            강화학습(Reinforcement Learning)       간단한 이론부터 먼저 알아보고 세부적으로 알아보도록 하겠습니다.   지도학습 (Supervised Learning)   지도학습은 학습에 사용되는 데이터와 그 정답(label)을 이용해서 데이터의 특성과 분포를 학습하고 미래결과를 예측하는 방법           Regression(회귀)                       학습된 결과를 바탕은 연속적인 숫자값을 예측                        Linear Regression(선형회귀)  : ‘얼마나’를 예측하는 방법                        Classification(분류)              binary classification (둘 중 하나를 예측)       multinomial classification (여러 개 중 하나를 예측)           비지도학습 (unsuperviese learning)   비지도학습은 학습에 사용되는 데이터가 label 이 없는 데이터가 사용됩니다. 이 부분이 지도학습과 가장 큰 차이입니다. 비지도학습은 정답(label)이 없는 데이터만을 이용하기 떄문에 입력값 자체가 가지고 있는 특성과 분포를 이용해서 Grouping하는 Clustering(군집화)하는데 주로 사용합니다.   Classification(분류) VS clustering(군집화)           Clustering(군집화) : 비슷한 데이터끼리 Grouping 해주는 것            Classification(분류) : 어떤 분류에 속하는가에 대한 정답을 예측.       준지도학습 (SemiSupervised Learning)   지도학습 + 비지도학습 데이터의 일부분만 label 이 제공되는 경우!!   강화학습 (Reinforcement Learning)   위에서 말한 3가지 방식과는 완전히 다른 학습 방법 Agent, Environment, Action, Reward 개념을 이용 게임쪽에서 많이 사용되는 학습방법 google 알파고의 메인 알고리즘이 바로 이 강화학습.   많은 학습방법이 있지만 이번시간에는 지도학습에 대하여 알아보도록 하겠습니다. 먼저 실습에 앞서 미분에 대하여 간략하게 정리하고 넘어가도록 하겠습니다.   미분   어떤 함수의 정의역 속 각점에서 독립변수의 값의 변화량과 함수 값의 변화량 비율의 극한 혹은 극한의 집합. 치역으로 가지는 새로운 함수입니다.   미분에는 크게 두가지 방식이 있습니다. 해석미분과 수치미분이 있습니다.   해석 미분 (Anaytical differentiation)   종이와 펜을 가지고 논리적인 전개로 미분을 수행하는 해석미분   수치미분   해석미분으로 문제를 해결할 수 없을때 수치적 근사값을 이용해서 미분을 수행하는 방법입니다. 한가지 조심해야할점은 delta_x라고 0과 근사한 값을 이용해야 하는데 delta_x는 소수점 8자리 이하로 내려가면 안됩니다. (파이썬에러) 그렇기 때문에 일반적으로 delta_x를 0.00001 수준으로 설정해서 수치미분을 수행합니다.   수치미분에는 전형차분, 후향차분, 중앙차분이 있습니다. 이번시간에는 중앙차분 방식을 사용하도록 하겠습니다.   파이썬 코드를 통하여 수치미분을 알아보도록 하겠습니다.   # f(x) = x^2 # f'(5) = 10  def numerical_derivative(f, x):     # f : 미분하려는 함수가 들어와요!     # x : 미분값을 알고자하는 입력값.     # delta_x는 1e-4 ~ 1e-6 정도의 수로 설정하면 됩니다 !! (1e-4)     # delta_x는 0과 가까운 작은값을 이용하고 1e-8이하는 사용하면 안됩니다.     delta_x = 1e-4          # 중앙차분     return (f(x+delta_x) -f(x-delta_x)) / (2*delta_x)     # 미분하려는 함수를 만들어요! # f(x) = x^2  def my_func(x):          return x**2      # 함수 f(x) = x^2 에서 미분계수 f'(5)를 구하세요!  result = numerical_derivative(my_func, 5) print(result) # 9.9999999   그렇다면 변수가 한 가지가 아닌 다변수 함수에 대한 미분을 해보도록 하겠습니다. 이번에는 편미분을 이용하여 코드로 구현해보도록 하겠습니다.   # f(x,y) = 2x +3xy + y^3 # f'(1.0, 2.0) == (8, 15)  # 수치미문 최종코드  import numpy as np def numerical_derivative(f, x):     # f : 미분하려고 하는 다변수 함수     # x : 모든 변수를 포함하고 있어야 해요! ndarray (차원상관없이)     delta_x = 1e-4 #     derivative_x = np.zeros((3,4))     derivative_x = np.zeros_like(x) # 미분한 결과를 저장하는 ndarray          # iterator 를 이용해서 입력변수 x에 대해 편미분을 수행     it = np.nditer(x, flags=['multi_index'])          while not it.finished:         idx = it.multi_index # iterator의 현재 index를 추출(tuple로 추출)                  # 현재 같의 값을 어딘가에 잠시 저장해야해요!!         # 해당되는 x에 맞춰서 넣어줘야 하기떄문에 그렇습니다.         tmp = x[idx]                  x[idx]= tmp + delta_x          fx_plus_delta = f(x) # f(x + delta_x)                  x[idx]= tmp - delta_x         fx_minus_delta = f(x) # f(x - delta_x)                  derivative_x[idx] = (fx_plus_delta - fx_minus_delta) / (2 * delta_x)                  x[idx] = tmp # 데이터를 원상복구                  it.iternext()              return derivative_x   def my_func(x):         return x**2 ## f(x) = x^2에서 f'(3) ?? result = numerical_derivative(my_func,np.array([3.0])) print(result) # [6.]   # 이변수 함수를 미분해 보아요! # f(x,y) = 2x + 3xy +np.power(y,3) def my_func(input_data):     x = input_data[0]     y = input_data[1]          return 2*x + 3*x*y + np.power(y,3)  result = numerical_derivative(my_func, np.array([1.0,2.0])) print(result) # [ 8.         15.00000001]   Regression   Linear Regression 에 대하여 알아보도록 하겠습니다.  Linear Regression란 Training Data Set 을 이용해서 학습된 결과를 만드록 연속적인 숫자값을 예측하는 것을 의미합니다.   간단한 예제를 통하여 알아보도록 하겠습니다.   # 문제를 단순화 시켜서 다음의 데이터를 이용해 보아요! # 공부시간(x), 시험점수 (t)를 이용해서 데이터를 표현해 보아요! # 이 데이터를 2차원 평면에 scatter(산점도)를 이용해서 표현해 보아요!!  import numpy as np import pandas as pd import matplotlib.pyplot as plt  data = {'공부시간(x)' : [1,2,3,4,5,7,8,10,12,13,14,15,18,20,25,28,30],        '시험점수(t)':[5,7,20,31,40,44,46,49,60,62,70,80,85,91,92,97,98]}  df = pd.DataFrame(data)  display(df.head())  plt.scatter(df['공부시간(x)'], data['시험점수(t)'])      이 데이터를 이용해서 직선 몇가지를 그려보도록 하겠습니다. 직선이니까 y = ax+b (a는 기울기(slop), b는 절편(intercept)) 로 표현 하겠습니다.   import numpy as np import pandas as pd import matplotlib.pyplot as plt  data = {'공부시간(x)' : [1,2,3,4,5,7,8,10,12,13,14,15,18,20,25,28,30],        '시험점수(t)':[5,7,20,31,40,44,46,49,60,62,70,80,85,91,92,97,98]}  df = pd.DataFrame(data)  display(df.head())  plt.scatter(df['공부시간(x)'], df['시험점수(t)'])  # 직선ㅇ르 표현하는게.. y = ax +b plt.plot(df['공부시간(x)'],df['공부시간(x)']*2 +3, color='g') plt.plot(df['공부시간(x)'],df['공부시간(x)']*5 -7, color='magenta') plt.plot(df['공부시간(x)'],df['공부시간(x)'] +8, color='r') plt.plot(df['공부시간(x)'],df['공부시간(x)']*4 -10, color='b')  plt.show()      초기의 기울기 a와 절편 b는 랜덤하게 결정되고 그 이후 우리가 가지는 데이터의 특성을 가장 잘 표현하기 위한 직선을 찾아가는 과정이 진행되게 됩니다. 이 과정을 우리는 학습(learning)이라고 합니다. 결국은 데이터를 가장 잘 표현하는 직선(y)를 만들 수 있고 이 직선을 predictive model이라고 합니다.   수학과의 표기상의 차이점은 y = ax +b 수학에서 이렇게 표현하지만 regression에서는 y = Wx + b (W : weight, 가중치) (b : bias, 바이어스)로 표현합니다.   오차   하지만 아무래도 직선으로 표시하다 보면 근사치를 구하기 때문에 정확하게 일치하지 않고 오차가 발생합니다. 이것을 그림으로 표현하면 하기그림과 같습니다.      노란색의 y값 차이만큼의 수치차이가 나게되며 이것을 수식으로 표현하면 n번째 위치에서의 오차는 tn - (wxn + b)이 됩니다. 하지만 부호가 존재하기 때문에 실직적으로 정확한 오차를 판별하기 어려우며 이를 해결하기 위해 최소제곱법으로 오차표현하면   [tn - (wxn + b)]^2 / n   입니다.   오차와 y = Wx + b (W : weight, 가중치) (b : bias, 바이어스) 의 관계에 대하여 다시 함수식을 나타낼 수 있는데 이것은 손실함수(loss function)이라고 부르며 이것을 수식으로 나타내면 하기와 같습니다.   import numpy as np import matplotlib.pyplot as plt  # training data set x = np.arange(1,101) t = np.arange(1,101)  # b를 제외하고 w와 loss의 관계에 대하여 알아보아요 W = np.arange(-10,13)  loss = []  for tmp in W:     loss.append(np.power(t-tmp*x,2).mean())  plt.plot(W, loss) plt.show()     ","categories": ["Python"],
        "tags": ["Machin learning"],
        "url": "http://localhost:4000/python/Machine_learning/",
        "teaser": "http://localhost:4000/assets/image/1200px-Pandas_logo.svg.png"
      },{
        "title": "[Python] Machine Learning-2",
        "excerpt":"Linear Regression Model   Linear Regression을 함수로 표현하기전에 경사하강법에 대하여 알아보도록 하겠습니다.   학습데이터를 관통하는 하나의 직선이 존재한다는 Hypothesis를 만들어 낼 수 있으며 그 식은 H(x) = Wx +b라고 표현하였습니다. 그렇다면 최적의 Hypothesis를 만들기 위해서는 loss function 혹은 cost function 의  최소값을 구해야합니다.하지만 이것을 구하기 쉽지 않기때문에 우리는 경사하강법을 이용하여 최소값에 근사한 값을 구해보도록 하겠습니다.   경사하강법   아래 그림대로 손실함수 그래프를 따라가면서 손실함수가 최소가 되는 지점에서의 W를 구하는 것입니다. W가 변화하면서 Hypothesis는 오른쪽 아래의 그림처럼 변화하게 됩니다.      이것을 수식으로 표현하면 하기와 같습니다.      경사하강법의 다음 도착점은 W와 α(Learning rate) 그리고 손실함수의 미분값곱의 차로 결정됩니다. 여기서 Learning rate 값이 너무 크거나 작으면 하기 그림과 같은 상황이 벌어지게 됩니다.      그렇기 때문에 적절한 α을 찾아서 배정해주는 것이 중요합니다.   그렇다면 이번에는 코드로서 표현을 해보도록 하겠습니다. 학습데이터는 이전시간에 사용하였던 공부시간과 시험점수에 대한 데이터를 동일하게 사용하도록 하겠습니다.   코드를 구현하는 절차는 하기와 같습니다.                  Training Data Set을 준비  머신러닝에 입력으로 사용될 데이터를 NumPy array(ndarray)형태로 준비합니다.                  Linear Regression Model을 정의  y = Wx + b =&gt; model을 프로그램적으로 표현합니다. W 와 b에 대한 변수 선언한 후 초기값은 랜덤값을 이용합니다.                  loss function을 정의         손실함수(loss function)에 대한 코드를 작성 후 matrix처리해야해요                  learning rate의 정의         일반적으로 customizing이 되는 값으로 초기에는 0.001정도로 설정해서 사용하고 loss값을 보고 수치를 조절할 필요가 있습니다.                  학습을 진행         반복적으로 편미분을 이용해서 W와 b를 update하는 방식으로 구현            import numpy as np import matplotlib.pyplot as plt  data = {'공부시간(x)' : [1,2,3,4,5,7,8,10,12,13,14,15,18,20,25,28,30],        '시험점수(t)':[5,7,20,31,40,44,46,49,60,62,70,80,85,91,92,97,98]} x_data = np.array([1,2,3,4,5,7,8,10,12,13,14,15,18,20,25,28,30]).reshape(-1,1) t_data = np.array([5,7,20,31,40,44,46,49,60,62,70,80,85,91,92,97,98]).reshape(-1,1)  #데이터의 분포를 scatter로 확인  # plt.scatter(x_data.ravel(), y_data.ravel()) # ravel() 무조건 1차원으로 변경 # plt.show()  # Linear Regression Model을 정의 # y = Wx+b W = np.random.rand(1,1) # matrix b = np.random.rand(1)   # scalar  # H = W*x + b # y대신에 Hypothesis 를 나타내는 H를 변수명으로 썼어요!  # loss function  def loss_func(x,t):     y = np.dot(x,W)+b           return np.mean(np.power((t-y),2)) # (t-y)^2/n  # 미분함수 (중앙차분) def numerical_derivative(f, x):     delta_x = 1e-4     derivative_x = np.zeros_like(x)          it = np.nditer(x, flags=['multi_index'])          while not it.finished:         idx = it.multi_index                  tmp = x[idx]                  x[idx]= tmp + delta_x         fx_plus_delta = f(x)                  x[idx]= tmp - delta_x         fx_minus_delta = f(x)                  derivative_x[idx] = (fx_plus_delta - fx_minus_delta) / (2 * delta_x)                  x[idx] = tmp                  it.iternext()              return derivative_x  # prediction def predict(x):     return np.dot(x,W)+b # Hypthesis, Linear Regression Model  # learning rate라는 상수가 필요, 정의해야해요! learning_rate = 0.0001  # 미분을 진행할 loss_func에 대한 lambda 함수를 정의 f = lambda x: loss_func(x_data, t_data)  # 학습을 진행!! # 반복해서 학습을 진행 ( W 와 b를 update하면서 반복적으로 학습을 진행) for step in range(90000):     W = W -learning_rate * numerical_derivative(f, W) # W의 편미분     b = b -learning_rate * numerical_derivative(f, b) # W의 편미분          if step % 3000 == 0:         print('W : {}, b : {}, loss : {}'.format(W,b,loss_func(x_data, t_data)))  # 학습 종료 후  print(predict(19))  plt.scatter(x_data.ravel(), t_data.ravel())  plt.plot(x_data.ravel(), np.dot(x_data,W)+b, 'r') plt.show()      ","categories": ["Python"],
        "tags": ["Machin learning","Linear Regression","Gradient descent"],
        "url": "http://localhost:4000/python/Machine_learning2/",
        "teaser": "http://localhost:4000/assets/image/1200px-Pandas_logo.svg.png"
      },{
        "title": "[Python] Machine Learning-3",
        "excerpt":"Simple Linear Regression   이번 시간에는 실제 예제를 가지고 Linear Regression을 이용하여 예측 값을 산출해보도록 하겠습니다.   예제는 하기표처럼 온도와 오존량에 대한 데이터를 Training data로 사용할 예정이며 파일은 추가적으로 제공하도록 하겠습니다.                          Ozone       Solar.R       Wind       Temp       Month       Day                       0       41.0       190.0       7.4       67       5       1                 1       36.0       118.0       8.0       72       5       2                 2       12.0       149.0       12.6       74       5       3                 3       18.0       313.0       11.5       62       5       4                 4       NaN       NaN       14.3       56       5       5                 …       …       …       …       …       …       …                 148       30.0       193.0       6.9       70       9       26                 149       NaN       145.0       13.2       77       9       27                 150       14.0       191.0       14.3       75       9       28                 151       18.0       131.0       8.0       76       9       29                 152       20.0       223.0       11.5       68       9       30           저번시간과 똑같은 절차로 예측모델을 만들어 보도록 하겠습니다.           Raw Data Loading     Data Preprocessing ( 데이터 전처리 )     Training Data Set     초기 W, b 세팅     Loss function 정의     학습 예측 함수생성     기타 프로그램에사 필요한 변수 정의     학습진행     예측값 확인      import numpy as np import pandas as pd import matplotlib.pyplot as plt from data.my_library.machine_learning_library import numerical_derivative as nd  # 1. Raw Data Loading df = pd.read_csv('./data/ozone.csv') # display(df)  # 2. Data Preprocessing(데이터 전처리) # - 결측치 처리... # - 삭제, 값을 변경(평균, 최대, 최소), 값을 예측해서 값을 대체  # - 이상치 처리(outlier) # - 이상치를 검출하고, 변경하는 작업 # - 데이터 정규화 작업 # - 학습에 필요한 컬럼을 추출, 새로 생성.   # 필요한 column 만 추출 # 결치값을 제거!!   training_data = df[['Temp','Ozone', ]] # display(training_data) # print(training_data.shape) #(153, 2)   training_data = training_data.dropna(how='any') # display(training_data) # print(training_data.shape) #(116, 2)  # 3. Training Data Set x_data = training_data['Temp'].values.reshape(-1,1) t_data = training_data['Ozone'].values.reshape(-1,1)  # 4. Simple Linear Regression #    y = Wx + b //  W,b를 정의 W = np.random.rand(1,1) b = np.random.rand(1)  # 5. loss function 정의 def loss_func(x, t):     y = np.dot(x, W) + b     return np.mean(np.power(t-y,2)) # 최소제곱법  # 6. 학습종료 후 예측함수 def predict(x):     return np.dot(x,W) +b  # 7. 기타 프로그램에서 필요한 변수들을 정의 learning_rate = 1e-4  f = lambda x: loss_func(x_data, t_data)  # 8. 학습을 진행 for step in range(30000):     W -= learning_rate * nd(f, W)     b -= learning_rate * nd(f, b)          if step %3000 ==0:         print ('W : {}, b : {}, loss : {}'.format(W, b, loss_func(x_data,t_data)))      # 9. 그래프로 확인 plt.scatter(x_data, t_data) plt.plot(x_data, np.dot(x_data, W)+b, 'r') plt.show()  print(predict(62))   W : [[0.48898185]], b : [0.1382576], loss : 903.6007199549715 W : [[0.58275697]], b : [-1.13623806], loss : 861.0875644794504 W : [[0.59874403]], b : [-2.39947113], loss : 855.7685424676351 W : [[0.61459263]], b : [-3.65176381], loss : 850.5412536613877 W : [[0.63030397]], b : [-4.89321085], loss : 845.4041160065931 W : [[0.64587924]], b : [-6.12390617], loss : 840.3555747335402 W : [[0.66131962]], b : [-7.34394289], loss : 835.3941018864972 W : [[0.67662628]], b : [-8.55341332], loss : 830.518195861303 W : [[0.69180037]], b : [-9.75240898], loss : 825.7263809507612 W : [[0.70684304]], b : [-10.94102059], loss : 821.0172068981508      Scikit-learn   앞선 코드를 통하여 상기의 그래프를 얻었습니다. 육안으로 판단을 해보았을때 y 절편인 b 값이 좀더 내려오고 기울기값인 W 가 높은 값을 가져야만 할 것 같은데요. 물론 그래프의 조정이나 learning_rate를 조정하면서 원하는 결과치를 얻을 수 있겠지만 이번시간에는 Scikit-learn을 통해서 좀더 쉽게 최적의 그래프를 얻어보도록 하겠습니다. 코드를 통해서 알아보도록 하겠습니다.   import numpy as np import pandas as pd import matplotlib.pyplot as plt  from sklearn import linear_model  # 1. Raw Data Loading df = pd.read_csv('./data/ozone.csv') # display(df)  # 2. Data Preprocessing(데이터 전처리) # - 결측치 처리... # - 삭제, 값을 변경(평균, 최대, 최소), 값을 예측해서 값을 대체  # - 이상치 처리(outlier) # - 이상치를 검출하고, 변경하는 작업 # - 데이터 정규화 작업 # - 학습에 필요한 컬럼을 추출, 새로 생성.   # 필요한 column 만 추출 # 결치값을 제거!! #  training_data = df[['Temp','Ozone', ]]   training_data = training_data.dropna(how='any') # display(training_data) # print(training_data.shape) #(116, 2)  # 3. Training Data Set x_data = training_data['Temp'].values.reshape(-1,1) t_data = training_data['Ozone'].values.reshape(-1,1)  # 4. sklearn을 이용해서 linear regression model 객체를 생성 # 아직 완성되지않은( 학습되지 않은 모델을 일단생성) model = linear_model.LinearRegression()  # 5. Training Data Set을 이용해서 학습을 진행! model.fit(x_data, t_data)  # 6. W와 b 값을 알아내야 해요! print('W:{}, b:{}'.format(model.coef_, model.intercept_))  # W:[[2.4287033]], b:[-146.99549097]   # 7. 그래프로 확인해보아요! plt.scatter(x_data, t_data) plt.plot(x_data, np.dot(x_data, model.coef_)+model.intercept_, 'r') plt.show()   # 8. 예측을 한번 해보아요!! predict_val = model.predict([[62]]) print(predict_val) #[[3.58411393]]      Scikit-learn을 통해서 좀더 쉽게 최적의 그래프를 얻을 수 있었습니다. 그렇다면 왜 이런현상이 발생하는 것일까요?? 바로 데이터의 전처리가 잘안되서 발생하는 문제입니다.      그래프를 보면 노란색으로 표시된 부분의 데이터가 비정상적으로 튀는 것을 확인할 수 있습니다.   이상치 처리(Outlier)   Z-Score (분산, 표준편차를 이용하는 이상치 검출방식 - 통계기반) Tukey Outlier(4분위값을 이용하는 이상치 검출방식) 이상치(Outlier)는 속성의 값이 일반적인 값보다 편차가 큰 값을 의미. 즉, 데이터 전체 패턴에서 동떨어져 있는 관측치를 지칭!! 평균뿐아니라 분산에도 영향을 미치기 떄문에 결국은 데이터 전체의  안정성을 저해하는 요소. 그래서 이상치는 반드시 처리해야 하고 이것을 검출하고 처리하는데 상당히  많은 시간이 소요되는게 일반적  ","categories": ["Python"],
        "tags": ["Machin learning","Scikit-learn"],
        "url": "http://localhost:4000/python/Machine_learning-3/",
        "teaser": "http://localhost:4000/assets/image/1200px-Pandas_logo.svg.png"
      }]
